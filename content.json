[{"title":"Hello World","date":"2019-07-26T08:26:24.684Z","path":"2019/07/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"JVM-3.垃圾收集器与内存分配策略","date":"2019-07-21T16:46:15.000Z","path":"2019/07/22/JVM-3-垃圾收集器与内存分配策略/","text":"","tags":[]},{"title":"JVM-2.Java内存区域与内存溢出异常","date":"2019-07-21T15:43:00.000Z","path":"2019/07/21/JVM-2-Java内存区域与内存溢出异常/","text":"运行时数据区域 程序计数器(线程私有) Java虚拟机栈(线程私有) 本地方法栈(线程私有，执行本地方法) Java堆：所有的对象实例及数组都在堆上分配。基本采用分代回收，新生代（Eden/From Survivor/To Survivor），老年代。 方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Non-Heap非堆。HotSpot称之为永久代(也有回收，主要针对常量和对类的卸载。但效果一般，因为回收条件苛刻。) 运行时常量池：本是方法区的一部分，已经独立移出。用于存放编译期生成的各种字面量和符号引用。 直接内存：不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域。JDK1.4 NIO 使用Native函数库直接分配堆外内存。 对象探秘 对象创建 为新生对象分配内存，有两种方式可用。受到不同收集器的影响。 指针碰撞(Bump the pointer)。堆中内存规整，用指针划分使用过的和未使用的两块空间，分配内存就是指针向未使用空间移动。 空闲列表(Free List)。虚拟机需要维护一个列表，记录哪些内存块是可用的，分配空间时从列表中找到一块足够大的空间划分给新对象，同时更新列表。 Serial、ParNew带等Compact过程：指针碰撞；CMS等基于Mark-Sweep：空闲列表。 并发情况下争用同一地址创建对象，如何解决？ 虚拟机采用CAS+失败重试来保证更新操作的原子性。 方案二：本地线程分配缓冲(Thread local allocation buffer, TLAB). 每个线程预先在堆中拿出一小块私有，缓冲区分配满了，再同步锁定，分配新TLAB. 通过-XX:+/-UseTLAB设定。 对象的内存布局 对象头(Header，Mark Word) 存储对象自身的运行时数据，如哈希码，GC份代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。 有一部分虚拟机实现，会在对象头中存储类型指针。与对象的访问定位有关。 实例数据(Instance data) 父类+子类的各种类型的字段内容。存储顺序受到VM分配策略和字段在源码中定义顺序影响。 对其填充(Padding) HotSpot虚拟机要求对象起始地址必须是8字节的整数倍。 对象的访问定位 句柄访问：包含了对象实例数据和类型数据各自的具体地址信息。 直接指针访问：实例对象中存储类型数据指针。 异常 OutOfMemoryError 堆溢出 虚拟机栈和本地方法栈溢出 方法区和运行时常量池溢出 本机直接内存溢出","tags":[{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","permalink":"https://northernw.github.io/tags/深入理解Java虚拟机/"}]},{"title":"Gson源码解析和设计模式","date":"2019-07-18T20:00:15.000Z","path":"2019/07/19/Gson源码解析和设计模式/","text":"Gson源码版本12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; summary 抽象类TypeAdapter，委托模式，处理json字符串和特定类型对象之间的相互转换。抽象方法read和write在具体的TypeAdapter有各自的实现，比较复杂的包括集合类型的CollectionTypeAdapterFactory.Adapter（比如read时，要实例化集合，再循环处理集合内元素）、自定义对象类型的ReflectiveTypeAdapterFactory.Adapter（比如需要循环处理类内field的read和write）。 接口TypeAdapterFactory，抽象工厂模式，创建给定类型的TypeAdapter。基础类型已经预先创建typeAdapter（调用factory.create时，如果是给定的类型，返回预定义的adapter），Collection、自定义类型等包含泛型的，在运行时create（因为会有不同的要素，比如constructor、elementType、boundFields等）。 序列化时，泛型类型通过TypeAdapterRuntimeTypeWrapper进行处理。会判断使用rawType带过来的类型还是运行时真实value的类型进行后续处理。 设计模式工厂模式TypeAdapterFactory.create提供给定TypeToken的TypeAdapter. 12345678public interface TypeAdapterFactory &#123; /** * Returns a type adapter for &#123;@code type&#125;, or null if this factory doesn't * support &#123;@code type&#125;. */ &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type);&#125; 不同adapter不同factoryGson内置factory12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 List&lt;TypeAdapterFactory&gt; factories = new ArrayList&lt;TypeAdapterFactory&gt;();// Gson的类型 // built-in type adapters that cannot be overridden factories.add(TypeAdapters.JSON_ELEMENT_FACTORY); factories.add(ObjectTypeAdapter.FACTORY); // the excluder must precede all adapters that handle user-defined types factories.add(excluder);// 用户定义的TypeAdapters // user's type adapters factories.addAll(typeAdapterFactories);// 基础类型 // type adapters for basic platform types factories.add(TypeAdapters.STRING_FACTORY); factories.add(TypeAdapters.INTEGER_FACTORY); factories.add(TypeAdapters.BOOLEAN_FACTORY); factories.add(TypeAdapters.BYTE_FACTORY); factories.add(TypeAdapters.SHORT_FACTORY); factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter(longSerializationPolicy))); factories.add(TypeAdapters.newFactory(double.class, Double.class, doubleAdapter(serializeSpecialFloatingPointValues))); factories.add(TypeAdapters.newFactory(float.class, Float.class, floatAdapter(serializeSpecialFloatingPointValues))); factories.add(TypeAdapters.NUMBER_FACTORY); factories.add(TypeAdapters.CHARACTER_FACTORY); factories.add(TypeAdapters.STRING_BUILDER_FACTORY); factories.add(TypeAdapters.STRING_BUFFER_FACTORY); factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL)); factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER)); factories.add(TypeAdapters.URL_FACTORY); factories.add(TypeAdapters.URI_FACTORY); factories.add(TypeAdapters.UUID_FACTORY); factories.add(TypeAdapters.LOCALE_FACTORY); factories.add(TypeAdapters.INET_ADDRESS_FACTORY); factories.add(TypeAdapters.BIT_SET_FACTORY); factories.add(DateTypeAdapter.FACTORY); factories.add(TypeAdapters.CALENDAR_FACTORY); factories.add(TimeTypeAdapter.FACTORY); factories.add(SqlDateTypeAdapter.FACTORY); factories.add(TypeAdapters.TIMESTAMP_FACTORY); factories.add(ArrayTypeAdapter.FACTORY); factories.add(TypeAdapters.CLASS_FACTORY);// 组合类型和自定义类型 // type adapters for composite and user-defined types factories.add(new CollectionTypeAdapterFactory(constructorConstructor)); factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization)); factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor)); factories.add(TypeAdapters.ENUM_FACTORY); factories.add(new ReflectiveTypeAdapterFactory( constructorConstructor, fieldNamingPolicy, excluder)); todo map 复杂key的序列化 map peek == JsonToken.BEGIN_ARRAY reflectiveTypeAdapter 多个泛型 [done. read时根据name和TypeToken，write时根据TypeAdapterRuntimeTypeWrapper] toJson时候，type里带实例的runtime type? [done. TypeAdapterRuntimeTypeWrapper处理] JsonAdapterAnnotationTypeAdapterFactory [almost done. 获取filed上注解的TypeAdapter进行后续处理] $Gson$Types.resolve [done] JsonWriter和JsonReader的读写","tags":[{"name":"Gson","slug":"Gson","permalink":"https://northernw.github.io/tags/Gson/"}]},{"title":"OKHttp源码解析和设计模式","date":"2019-07-16T20:00:47.000Z","path":"2019/07/17/OKHttp源码解析和设计模式/","text":"","tags":[{"name":"OKHttp","slug":"OKHttp","permalink":"https://northernw.github.io/tags/OKHttp/"}]},{"title":"剑指offer-面试需要的基本知识","date":"2019-07-15T15:35:14.000Z","path":"2019/07/15/剑指offer-面试需要的基本知识/","text":"编程语言单例模式java版好的解法 懒汉模式，field直接创建实例 volatile+双重检查，加volatile是防止其他线程在本线程刚分配内存、还未初始化时就得到instance 静态内部类，内部类中在filed创建实例，实现在使用时才创建 数据结构数组 找出数组中重复的数字。 最简单的是哈希表，时间O(1)，空间O(n). 如果空间优先，允许修改原数组。遍历数组的过程中，判断值m与下标m的位置的值是否相同，相同，找到；不相同，替换值m与下标m位置的值。时间O(n)，时间O(1). 空间优先，不允许修改原数组。利用二分查找的思想。将数组与n的中值比较，判断出重复的数是小于还是大于中值，继续二分中值。 二维数组中的查找，行从左到右升序，列从上到下升序，判断是否存在给定的数。clue：从右上或左下开始判断。 字符串注意某些情形下，从后往前处理，可以减少移动的次数。 链表链表创建、插入、删除。 树 遍历 （根节点所在位置）前序，中序，后序 宽度优先：利用队列，存储当前深度的节点 重建二叉树 二叉树的下一个节点 栈和队列 相互实现 算法和数据操作递归和循环递归的实现方式代码简洁，但性能不如循环的实现方式 查找和排序重点掌握二分查找、归并排序和快速排序 回溯法在二维数组上搜索路径 动态规划与贪婪算法动态规划：求某个问题的最优解，且问题可以分为多个子问题。（自上而下：递归，自下而上：循环）贪婪算法：存在特殊的选择，一定能得到最优解。 位运算与、或、异或、左移、右移。","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://northernw.github.io/tags/剑指offer/"}]},{"title":"剑指offer-基础知识","date":"2019-07-14T16:06:22.000Z","path":"2019/07/15/剑指offer-基础知识/","text":"编程语言pass 实现Singleton模式 java volatile+双重检查 内部类 数据结构二维数组中的查找算法和数据操作","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://northernw.github.io/tags/剑指offer/"}]},{"title":"Spring Framework Reference Documentation","date":"2019-07-11T16:18:27.000Z","path":"2019/07/12/Spring-Framework-Reference-Documentation/","text":"Overview","tags":[{"name":"spring","slug":"spring","permalink":"https://northernw.github.io/tags/spring/"}]},{"title":"关于ExceptionHandler与ResponseBody的一次排查","date":"2019-07-11T14:41:49.000Z","path":"2019/07/11/关于ExceptionHandler与ResponseBody的一次排查/","text":"问题工作中，在使用@ExceptionHandler作为controller全局异常处理的过程中，发现@ResponseBody注解并不能像往常一样返回json格式的数据，而是返回了xml格式的数据。 结论错误认识 @ResponseBody不意味着json格式响应，而是指controller的返回结果直接写回response，无需经过ModelAndView。见spring文档 The @ResponseBody annotation is similar to @RequestBody. This annotation can be placed on a method and indicates that the return type should be written straight to the HTTP response body (and not placed in a Model, or interpreted as a view name) 新认识 HttpMessageConverter才是进行数据格式转换的关键 经过试错发现，在request header中加入Accept application/json可以使原问题得到正确的json响应 遗留问题 工程中其他请求的request header中没有Accept application/json也能得到json响应，是为什么？ 记录下排查过程 怀疑@ResponseBody注解未生效 查阅后得知spring3.1版本已修复 （知道自己对@ResponseBody有误解后，就明白这并不是个问题，xml响应也是注解的结果） 百思不得其解，在方法中使用HttpServletResponse response直接输出json响应暴力解决。仔细想想，本质上是一致的。 12response.setContentType(&quot;application/json;charset=UTF-8&quot;);response.getWriter().write(gson.toJson(re)); 排除spring版本影响 工程依赖过多，更改版本错误重重，临时用springboot搭建了web，使用4.3.9.RELEASE（原工程版本）和5.1.8.RELEASE，配合@RestController，无需Accept application/json就能得到json响应 关于遗留问题工程中其他请求的request header中没有Accept application/json也能得到json响应，是为什么？ 差别在于，异常处理与正常返回用到的RequestResponseBodyMethodProcessor不是同一个实例，异常的是在ExceptionHandlerExceptionResolver中的，正常的是在RequestMappingHandlerAdapter.前者比之后者，缺少springmvc-config.xml中自定义的MessageConverter，例如MappingJackson2HttpMessageConverter。 123456789101112&lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"com.jd.common.xss.CustomObjectMapper\" /&gt; &lt;/property&gt;&lt;/bean&gt; 在writeWithMessageConverters方法中，异常resolver返回的b有7个，排序后最前的是application/xml，正常resolver返回9个，排序最前是上面自定义的application/json;charset=UTF-8，因此，最终返回结果有格式上的差异。AbstractMessageConverterMethodProcessor#writeWithMessageConverters123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081HttpServletRequest request = inputMessage.getServletRequest();// 根据request的accept得到请求支持的返回格式 aList&lt;MediaType&gt; requestedMediaTypes = getAcceptableMediaTypes(request);// 得到controller方法支持的返回格式 b &lt;-- 差别在这里List&lt;MediaType&gt; producibleMediaTypes = getProducibleMediaTypes(request, valueType, declaredType);if (outputValue != null &amp;&amp; producibleMediaTypes.isEmpty()) &#123; throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);&#125;// 对比a和b，得到所有兼容的返回格式 cSet&lt;MediaType&gt; compatibleMediaTypes = new LinkedHashSet&lt;MediaType&gt;();for (MediaType requestedType : requestedMediaTypes) &#123; for (MediaType producibleType : producibleMediaTypes) &#123; if (requestedType.isCompatibleWith(producibleType)) &#123; compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType)); &#125; &#125;&#125;if (compatibleMediaTypes.isEmpty()) &#123; if (outputValue != null) &#123; throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes); &#125; return;&#125;// 将c排序List&lt;MediaType&gt; mediaTypes = new ArrayList&lt;MediaType&gt;(compatibleMediaTypes);MediaType.sortBySpecificityAndQuality(mediaTypes);// 从c中得到排序较靠前的某个Concrete返回格式 dMediaType selectedMediaType = null;for (MediaType mediaType : mediaTypes) &#123; if (mediaType.isConcrete()) &#123; selectedMediaType = mediaType; break; &#125; else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) &#123; selectedMediaType = MediaType.APPLICATION_OCTET_STREAM; break; &#125;&#125;// 以下根据d得到对应的messageConverter，输出相应格式的结果if (selectedMediaType != null) &#123; selectedMediaType = selectedMediaType.removeQualityValue(); for (HttpMessageConverter&lt;?&gt; messageConverter : this.messageConverters) &#123; if (messageConverter instanceof GenericHttpMessageConverter) &#123; if (((GenericHttpMessageConverter) messageConverter).canWrite( declaredType, valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); if (outputValue != null) &#123; addContentDispositionHeader(inputMessage, outputMessage); ((GenericHttpMessageConverter) messageConverter).write( outputValue, declaredType, selectedMediaType, outputMessage); if (logger.isDebugEnabled()) &#123; logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\"); &#125; &#125; return; &#125; &#125; else if (messageConverter.canWrite(valueType, selectedMediaType)) &#123; outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(), inputMessage, outputMessage); if (outputValue != null) &#123; addContentDispositionHeader(inputMessage, outputMessage); ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage); if (logger.isDebugEnabled()) &#123; logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\"); &#125; &#125; return; &#125; &#125;&#125; 再来看看ExceptionHandlerExceptionResolver和RequestMappingHandlerAdapter中的RequestResponseBodyMethodProcessor为什么有不一样的messageConverters呢？ 跟踪不到setMessageConverters的直接调用，两个类的setMessageConverters都分别调用了2次，一次7个，一次9个，AnnotationDrivenBeanDefinitionParser#parse也分别执行了两次，一次7，一次9，可以推测是这个类触发了eher和rmhq的实例化. 123public void setMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) &#123; this.messageConverters = messageConverters;&#125; 那么，问题又回到，为什么异常处理的时候，用到的eher实例是7个的那个呢？ 看不动了，缓缓。需要从上至下了解spring的启动。","tags":[{"name":"springmvc","slug":"springmvc","permalink":"https://northernw.github.io/tags/springmvc/"},{"name":"springboot","slug":"springboot","permalink":"https://northernw.github.io/tags/springboot/"},{"name":"ExceptionHandler","slug":"ExceptionHandler","permalink":"https://northernw.github.io/tags/ExceptionHandler/"},{"name":"ResponseBody","slug":"ResponseBody","permalink":"https://northernw.github.io/tags/ResponseBody/"}]},{"title":"剑指offer-关于面试","date":"2019-07-10T11:08:04.000Z","path":"2019/07/10/剑指offer-关于面试/","text":"面试的形式 电话面试 环境安静 用形象化的语言把细节说清楚 共享桌面远程面试：考察编程习惯和调试能力 思考清楚再编码 良好的代码命名和缩进对齐习惯 能够进行单元测试：断点，单步跟踪，查看内存，分析调用栈 现场面试 不迟到 注意面试流程 准备几个问题 面试的环节 行为面试：5~10分钟，性格特点，项目经历，暖场 30s~1min 简单自我介绍：主要学习、工作经历 若详细问项目，STAR模型 Situation：项目背景 Task：自己完成的任务 Action：为完成任务自己做了哪些工作，是怎么做的 Result：自己的贡献 其他常见问题 该项目中碰到的最大问题是什么，怎么解决的？ 从这个项目中学到了什么？ 什么时候会和其他团队成员（RD、QA、UED、PM）有什么样的冲突，你们是怎么解决冲突的？ 掌握的技能 了解：只上过课或看过书，没有做过实际项目，不建议列在简历上，除非是应聘职位需要 熟悉：实际项目中使用某项技术很长时间，通过查阅文档可以独立解决大部分问题 项目开发过程中用到的技能，可以用“熟悉” 毕业设计用到的技能 为什么跳槽？ no: 老板太苛刻，同事太难相处，加班太频繁，工资太低 ok: 现在的工作做了一段时间，已经没有太多的激情了，因此希望寻找一份更有挑战的工作。再论述为什么有些厌倦现在的职位，以及面试的职位我为什么会有兴趣。 技术面试：40~50分钟 基础知识扎实全面，包括编程语言、数据结构、算法等 能写出正确的、完整的、鲁棒的高质量代码 能思路清晰地分析、解决复杂问题 能从时间、空间复杂度两方面优化算法效率 具备优秀的沟通能力、学习能力、发散思维能力等 应聘者提问 问与职位或项目相关的问题 不要问薪水 不要打听面试结果","tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://northernw.github.io/tags/剑指offer/"},{"name":"面试","slug":"面试","permalink":"https://northernw.github.io/tags/面试/"}]},{"title":"循序渐进Linux（5）-软件安装与管理","date":"2019-07-05T15:47:01.000Z","path":"2019/07/05/循序渐进Linux（5）-软件安装与管理/","text":"源码安装 下载解压 wget tar.. ./configure, Makefile make make install rpm安装 rpm -i[vh] file1.rpm file2.rpm 安装 rpm -q[ag] package1…packageN 查询 rpm -v[..] package1…验证 -K: –checksig rpm -U[] file1.rpm .. fileN.rpm 更新 rpm -e[] package1…N 删除 e=erase yum安装yellowdog updater modified 使用rpm安装yum 配置yum：包括资源镜像列表等 yum维护软件间的依赖性，可同时配置多个资源库，配置简单明了，保持与RPM数据库的一致性 yum的基本用法 安装 yum install xx 更新 yum check-update yum update yum update kernel kernel-source yum upgrade … 查询 yum info yum info vsftpd yum info perl* 可使用通配符 yum info updates yum info installed yum list updates yum list yum list gcc* … 不错的yum源 EPEL(Extra Packages for Enterprise Linux，企业版linux附加包)，epel-release RPMForge, rpmforge-release 二进制软件安装一般直接解压，或执行setup install install.sh等命令或脚本","tags":[{"name":"linux","slug":"linux","permalink":"https://northernw.github.io/tags/linux/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://northernw.github.io/tags/读书笔记/"},{"name":"循序渐进linux","slug":"循序渐进linux","permalink":"https://northernw.github.io/tags/循序渐进linux/"}]},{"title":"循序渐进Linux（4）-常用命令及使用技巧","date":"2019-07-04T20:21:39.000Z","path":"2019/07/05/循序渐进Linux（4）-常用命令及使用技巧/","text":"shell简介系统管理与维护 ls pwd cd date passwd su clear man who uname uptime last dmesg free ps: ps -ef, ps aux top 文件管理与编辑 mkdir more cat diff grep rm touch ln file cp find split mv 压缩与解压4.4 暂停 磁盘管理与维护网络设置与维护文本编辑vi","tags":[{"name":"linux","slug":"linux","permalink":"https://northernw.github.io/tags/linux/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://northernw.github.io/tags/读书笔记/"},{"name":"循序渐进linux","slug":"循序渐进linux","permalink":"https://northernw.github.io/tags/循序渐进linux/"}]},{"title":"循序渐进Linux（2）-系统基本结构","date":"2019-07-04T12:00:28.000Z","path":"2019/07/04/循序渐进Linux（2）-系统基本结构/","text":"控制台的使用控制台 桌面控制台 字符控制台 默认有6个字符控制台，独立作业，互不影响。 图形界面切换到字符界面：ctrl+alt+F1~F6 字符界面切换到图形界面：在字符界面输入命令“startx”或者ctrl+alt+F7组合键 系统与硬件硬件资源管理 查看系统PCI设备lspci 查看CPU信息more /proc/cpuinfo查看系统物理CPU个数cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l 查看系统内存信息more /proc/meminfo 查看磁盘分区信息fdisk -l 外在设备的使用挂载mount -t 文件系统类型 设备名 挂载目录临时挂载点/mnt，手动挂载/media，自动挂载/run，CentOS 7.x版本自动挂载目录，所有移动设备自动挂载到该目录下例如：挂载U盘，假如设备名为/dev/sda1，建立/mnt/usb进行挂载mount -t vfat /dev/sda1 /mnt/usb 卸载umount 挂载目录例如：umount /mnt/usb 文件系统结构目录结构经典树形目录 常见目录结构： /boot 存放启动linux的核心文件 /bin和/sbin 存放可执行的二进制文件 /sbin s: super user，存放只有超级用户才能执行的命令 /home 系统中每个用户的工作目录 /lib 存放共享程序库和映像文件，供很多程序使用 /root 超级用户root的默认主目录。一般用户没有进入这个目录的权限 /run 外设的自动挂载点目录 /lost+found 保存丢失的文件。不恰当的关机操作和磁盘操作均会导致文件丢失，这些会丢失的文件会临时放在/lost+found下，系统重启后，fsck程序能发现这些文件。 /tmp 临时文件目录 系统核心组成 内存管理：合理有效地管理整个系统的物理内存，同时快速响应内核各个子系统对内存分配的请求。 进程管理：控制系统进程对CPU的访问。进程调度。 进程间通信：控制不同进程之间在用户空间的同步、数据共享和交换。例如，一个进程在等待硬件操作时是挂起的，等硬件操作完成，进程被恢复执行。协调这个过程的就是进程间的通信机制。 虚拟文件系统：用一个通用的文件模型表示各种不同的文件系统，屏蔽了具体文件系统的差异。分为逻辑文件系统和设备驱动程序。前者指linux支持的文件系统，如ext2、ext3、xfs等，后者指为每一种硬件控制器所编写的设备驱动程序模块。 网络接口：提供了对各种网络标准的实现和各种网络硬件的支持。 运行机制 init系统，初始化 runlevel与target 系统关机过程 系统服务管理工具systemd 启动、停止、重启服务 查看、禁止、启用服务 systemd与sysvinit命令对比 SecureCRT使用","tags":[{"name":"linux","slug":"linux","permalink":"https://northernw.github.io/tags/linux/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://northernw.github.io/tags/读书笔记/"},{"name":"循序渐进linux","slug":"循序渐进linux","permalink":"https://northernw.github.io/tags/循序渐进linux/"}]},{"title":"循序渐进Linux（1）","date":"2019-07-03T15:56:10.000Z","path":"2019/07/03/循序渐进Linux-1/","text":"key words单靠人工无法满足技术、业务、管理方面的要求重视标准化、自动化、稳定性、可靠性等需求 分区硬盘命名方案基于文件，一般命名如下：/dev/hda2/dev/sdb3 /dev：所有设备文件的存放目录 hd和sd: 代表分区所在设备类型，hd表示IDE硬盘，sd表示SCSI硬盘 a：表示分区在哪个设备上。/dev/hda表示第一块IDE硬盘，/dev/sdb表示第二块SCSI硬盘，/dev/sdd表示第四块SCSI硬盘，以此类推。 2：可以理解为第几个分区。linux前4个分区为主分区或扩展分区，逻辑分区从5开始。例如，/dev/hda2表示第一块IDE硬盘的第二个主分区或扩展分区，/dev/sdc6表示第三块SCSI硬盘的第二个逻辑分区。 其他常见分区 /boot: 存储系统的引导信息和内核信息等 /usr: 存储系统应用软件的安装信息 /var: 存储系统的日志信息","tags":[{"name":"linux","slug":"linux","permalink":"https://northernw.github.io/tags/linux/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://northernw.github.io/tags/读书笔记/"},{"name":"循序渐进linux","slug":"循序渐进linux","permalink":"https://northernw.github.io/tags/循序渐进linux/"}]},{"title":"ConcurrentHashMap笔记","date":"2019-06-27T11:09:41.000Z","path":"2019/06/27/ConcurrentHashMap笔记/","text":"spread假设table的长度为n=2^k，取模操作hash%n等价于hash&amp;(n-1)，n-1为mask(二进制的k-1个1)即，hash的低k位决定了桶的位置，k位以上的高位不起作用，如果不同hash的低k位相同，就会产生碰撞12345static final int spread(int h) &#123; // 将高16位与低16位异或，增加hash的分散度，降低碰撞概率 // 与上HASH_BITS，将最高位置为0，使spread结果为正数 return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; put循环做4件事情： 如果表为空，初始化表，继续 如果对应下标节点为空，cas插入，跳出 如果发现表正在迁移，帮助迁移，继续 执行put操作。如果链表长度超过阈值，转为树。如果为更新，直接返回，否则跳出 循环退出后，计数+1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public V put(K key, V value) &#123; return putVal(key, value, false);&#125;/** * Implementation for put and putIfAbsent * onlyIfAbsent: true 只替换为null值的node, false: 都替换 */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; // key value 不能为null if (key == null || value == null) throw new NullPointerException(); // 计算hash值 int hash = spread(key.hashCode()); int binCount = 0; // 循环执行 for (Node&lt;K, V&gt;[] tab = table; ; ) &#123; Node&lt;K, V&gt; f; int n, i, fh; // 如果table为空，初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 如果对应下标节点为空，直接插入 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // cas替换 if (casTabAt(tab, i, null, new Node&lt;K, V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin // 如果节点不为空，且节点的hash为-1，-1表示在迁移，则帮助迁移 &#125; else if ((fh = f.hash) == MOVED) // 此处，helpTransfer返回的tab为f的nextTable，或者为已完整迁移的新table tab = helpTransfer(tab, f); // 执行put操作 else &#123; V oldVal = null; // 请求同步锁，避免并发写操作 synchronized (f) &#123; // double check if (tabAt(tab, i) == f) &#123; // 链表结构 if (fh &gt;= 0) &#123; // 统计节点个数（非精确） binCount = 1; for (Node&lt;K, V&gt; e = f; ; ++binCount) &#123; K ek; // 找到相同的key，更新value if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; // 否则添加到链表尾部 Node&lt;K, V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K, V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; // 红黑树结构，TreeBin的hash为-2 Node&lt;K, V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; // 如果链表节点个数大于阈值，将链表转化为红黑树 // 如果原结构为红黑树，binCount=2 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); // oldVal不为null，说明是更新操作，节点个数无变化，直接返回 if (oldVal != null) return oldVal; break; &#125; &#125; &#125; // 到这里说明是添加操作，计数+1 addCount(1L, binCount); return null;&#125; initTable只有一个线程能进行初始化，其他线程让出CPU1234567891011121314151617181920212223242526272829303132333435/** * Initializes table, using the size recorded in sizeCtl. */private final Node&lt;K, V&gt;[] initTable() &#123; Node&lt;K, V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; // sc小于0，说明正在扩容或者迁移，让出cpu if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; // 当前线程获得初始化机会，cas sizeCtl为-1 try &#123; if ((tab = table) == null || tab.length == 0) &#123; // 如果sizeCtl有正值，用正值，否则采用默认容量 // sizeCtl什么时候有正值？有什么样的正值？ int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) new Node&lt;?, ?&gt;[n]; // 此时tab=table!=null，其他线程从本方法的循环中跳出 table = tab = nt; // 相当于n - n*1/4，即sc = 0.75*n // &gt;&gt;&gt; 无符号右移 sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; // 初始化完成后，sizeCtl=0.75*n sizeCtl = sc; &#125; // 初始化完成跳出循环 break; &#125; &#125; return tab;&#125; addCount12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; // 如果计数表不为空 // 或者cas baseCount失败，说明存在并发竞争 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; // 假设无竞争 boolean uncontended = true; // 如果计数表为空 // 如果计数表长度小于1 // 如果如果计数表随机位为null // 如果随机位不为空，且cas替换计数失败，说明有竞争 if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; // 还没看-- fullAddCount(x, uncontended); return; &#125; // if &lt;0, don't check resize, if &lt;= 1 only check if uncontended if (check &lt;= 1) return; // 累加baseCount和计数表里的值 s = sumCount(); &#125; // 判断是否要扩容 if (check &gt;= 0) &#123; Node&lt;K, V&gt;[] tab, nt; int n, sc; // 如果节点个数大于阈值，0.75n，类似于加载因子 // 并且table不为空 &amp;&amp; table长度未超过上限 while (s &gt;= (long) (sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; // 获取表长度的一个标识值 int rs = resizeStamp(n); // 如果在扩容，判断是否需要帮助迁移 if (sc &lt; 0) &#123; // 如果sc的高16位与标识符不等 // bug report: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8214427 // sc == rs + 1，存在bug，正确判断为 sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT + 1)，判断已无扩容线程 // sc == rs + MAX_RESIZERS，正确判断为 sc == (rs &lt;&lt; RESIZE_STAMP_SHIFT + MAX_RESIZERS)，判断扩容线程数已达最大 // 如果临时表nextTable为空，或者迁移下标transferIndex小于0，说明扩容结束 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) // 无需帮助扩容 break; // 否则，将sc cas为sc+1，表示sc低16位加1，即扩容线程数增加了一个 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) // 扩容 transfer(tab, nt); &#125; // 不处于扩容状态，cas sizeCtl为(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，标识有1个线程在扩容 // sizeCtl的高16位存储待扩容表长n的标识符，低16位存储[扩容线程数+1] else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) // 扩容 transfer(tab, null); s = sumCount(); &#125; &#125;&#125; sizeCtl的注释说明，当sizeCtl为负数时，-1标识表初始化，-(sizeCtl-1)标识活动的扩容线程数为什么在具体实现里，是sizeCtl的低16位，且需减去1的值，标识扩容线程数呢？(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)这里留个疑问，为什么是+2？不能是+1么？123456789/** * Table initialization and resizing control. When negative, the * table is being initialized or resized: -1 for initialization, * else -(1 + the number of active resizing threads). Otherwise, * when table is null, holds the initial table size to use upon * creation, or 0 for default. After initialization, holds the * next element count value upon which to resize the table. */private transient volatile int sizeCtl; resizeStampresizeStamp的结果作为扩容&amp;迁移时sizeCtl的高16位信息 sizeCtl为负数 标识着此次扩容&amp;迁移对应的表长n123456static final int resizeStamp(int n) &#123; // n的二进制前导0个数。因为表长n为2的次幂，每次扩容*2，意味着每次扩容前导0个数少1，用于判断是否为同一次扩容 // 将第16位或为1，是为了左移RESIZE_STAMP_SHIFT后为负数 // 1 &lt;&lt; (RESIZE_STAMP_BITS - 1) = (0b)1000 0000 0000 0000 return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));&#125; helpTransfer1234567891011121314151617181920212223242526272829/** * Helps transfer if a resize is in progress. */final Node&lt;K, V&gt;[] helpTransfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt; f) &#123; Node&lt;K, V&gt;[] nextTab; int sc; // 重新判断，旧表不为空，f为迁移节点，f关联的新表不为空 if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K, V&gt;) f).nextTable) != null) &#123; // 同addCount，循环判断是否需要帮助扩容 int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; // 不满足帮助扩容条件，跳出 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; // 否则，将sc低位cas+1（标识多一个线程扩容）成功后，帮助扩容 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab); break; &#125; &#125; // 返回新表 return nextTab; &#125; // 返回，此时table已是完成扩容的表 return table;&#125; transfer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164private final void transfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab) &#123; int n = tab.length, stride; // 计算步长，最短为16，最长为n（单CPU） if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range // 如果新表为空，先建新表，容量为2n if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings(\"unchecked\") Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) new Node&lt;?, ?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; // 从后向前迁移 transferIndex = n; &#125; int nextn = nextTab.length; ForwardingNode&lt;K, V&gt; fwd = new ForwardingNode&lt;K, V&gt;(nextTab); // 迁移推进标识，为false时跳出循环 // 标识是否进行迁移范围分配 boolean advance = true; // 全表迁移状态标识，true标识全部迁移完成 boolean finishing = false; // to ensure sweep before committing nextTab // 下标i,bound赋予初值，循环中会计算本次迁移的范围 for (int i = 0, bound = 0; ; ) &#123; Node&lt;K, V&gt; f; int fh; // 分配循环 while (advance) &#123; int nextIndex, nextBound; // i未到达本次迁移下界bound，或者全表迁移完成，标识停止推进，不会走到else if的范围分配 if (--i &gt;= bound || finishing) advance = false; // transferIndex小于0，没有可分配的迁移了，标识停止推进 else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; // 否则，若cas transferIndex成功（减去步长），分配迁移范围 &#125; else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; // 下界bound为更新后的transferIndex bound = nextBound; // 上界i为之前的transferIndex减1 i = nextIndex - 1; // 标识停止推进 advance = false; &#125; &#125; // i的临界判断 if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; // 如果全表已迁移完成，赋值table和sizeCtl if (finishing) &#123; nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; // i已到临界条件，本线程迁移工作完成，cas将sizeCtl-1 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; // 如果本线程是迁移工作中的最后一个活动线程，直接返回（sc为sizeCtl cas前的值） if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; // 如果还有其他线程在迁移，仅标识迁移完成，且推进继续（为了double check？check什么？） finishing = advance = true; i = n; // recheck before commit &#125; &#125; // 以下为迁移处理 // 如果节点为null，直接cas替换为fwd，成功则advance为true，重新分配 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); // 如果节点本身是fwd，说明本段步长已处理过，在while中重新分配范围 else if ((fh = f.hash) == MOVED) advance = true; // already processed // 桶的头节点加锁，迁移到新表 else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K, V&gt; ln, hn; // 链表结构 if (fh &gt;= 0) &#123; int runBit = fh &amp; n; // 假设n=2^k，按照hash第k位为0或1分为2组，0组放低位，1组放高位 // lastRun之后的节点直接用原节点，不新new // lastRun之前的节点在新表中逆序，之后的节点保持原序 Node&lt;K, V&gt; lastRun = f; for (Node&lt;K, V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; // 这里主要是判断lastRun的一串节点，要放高位还是低位 if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; // 重新遍历链表，链接出0组合1组节点，lastRun已链接上某个组，无需再遍历 for (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K, V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K, V&gt;(ph, pk, pv, hn); &#125; // 替换 setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); // 继续推进 advance = true; &#125; // 树结构 else if (f instanceof TreeBin) &#123; TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f; TreeNode&lt;K, V&gt; lo = null, loTail = null; TreeNode&lt;K, V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K, V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K, V&gt; p = new TreeNode&lt;K, V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K, V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K, V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125;&#125; get123456789101112131415161718192021222324252627public V get(Object key) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); // 表不为空，且hash取模所在桶不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; // 桶的头结点为要找的节点 if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; // 头结点hash&lt;0，说明为树或者迁移节点，调用find查找 else if (eh &lt; 0) // ForwardingNode -1; treeBin -2 return (p = e.find(h, key)) != null ? p.val : null; // 否则为链表格式，遍历查找 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; 作者说123456789101112131415....We do not want to waste* the space required to associate a distinct lock object with* each bin, so instead use the first node of a bin list itself as* a lock. Locking support for these locks relies on builtin* &quot;synchronized&quot; monitors.* * Using the first node of a list as a lock does not by itself* suffice though: When a node is locked, any update must first* validate that it is still the first node after locking it, and* retry if not. ....* * ....The transfer operation must also ensure that all* accessible bins in both the old and new table are usable by any* traversal. This is arranged in part by proceeding from the* last bin (table.length - 1) up towards the first. 引用一段并发分析Java 8 中 ConcurrentHashMap工作原理的要点分析 6.1初化的同步问题 表长度的分配并不是在构造函数中进行的，而是在put方法中进行的，也就是说这实际上是个懒汉模式。但是如果多个线程同时进行表长度的空间分配，显然是非线程安全的。所以只能有一个线程来进行创建表，其它线程会等待创建完成。ConcurrentHashMap类中设定一个volatile变量sizeCtl private transient volatile int sizeCtl; 然后通过CAS方法去修改它，如果有其它线程发现sieCtl为-1 U.compareAndSwapInt(this, SIZECTL, sc, -1) 就表示已经有线程正在创建表了，那么当前线程就会放弃CPU使用权（调用Thread.yield()方法），等待分初始化完成后继续进行put操作。否则当前线程尝试将siezeCtl修改为-1,若成功，就由当前线程来创建表。 6.2 put方法和remove方法之间的同步问题 在表的同一个槽上，一个线程调用put方法和另一个线程调用put方法是互斥的；在表的同一个槽上，一个线程调用remove方法和另一个线程调用remove方法也是互斥的；在表的同一个槽上，一个线程调用remove方法和另一个线程调用put方法也是互斥的。这些互斥操作在代码中都是通过锁来保证的。 6.3 put(或remove)方法和get方法的同步问题 实际上是不需要同步，先到先得。这主要由于Node定义中value和next都定义成了volatile类型。一个线程能否get到另一个线程刚刚put（或remove）的值，这主要由两个线程当前访问的结点所处的位置决定的。 6.4 get方法和扩容操作的同步问题 可以分成两种情况讨论 1）该位置的头结点是Node类型对象，直接get，即使这个桶正在进行迁移，在get方法未完成前，迁移完已成（槽被设置成了ForwordingNode对象），也没关系，并不影响get的结果，因为get线程仍然持有旧链表的引用，可以从当前结点位置访问到所有的后续结点，原因是新表中的节点是通过复制旧表中的结点得到的，所以新表的结点的next不会影响旧表中对应结点的next值。当get方法结束后，旧链表就不可达了，会被垃圾回收线程回收。 2）该位置的头结点是ForwordingNode类型对象（头结点的hash值 == -1），头结点是ForwordingNode类型的对象，调用该对象的find方法，在新表中查找。 所以无论哪种情况，都能get到正确的值。 6.5 put(或remove)方法和扩容操作的同步问题 同样可以分为两种情况讨论： 1）该位置的头结点是Node类型对象，put操作就走正常路线，先将Node对象放入到旧表中，然后调用addCount方法，判断是否需要帮助扩容。 2）该位置的头结点是ForwordingNode类型对象，那就会先帮助扩容，然后在新表中进行put操作。","tags":[{"name":"ConcurrentHashMap","slug":"ConcurrentHashMap","permalink":"https://northernw.github.io/tags/ConcurrentHashMap/"}]},{"title":"foreach中不宜进行remove/add等操作","date":"2019-06-19T17:26:18.000Z","path":"2019/06/20/foreach中不宜进行remove-add等操作/","text":"原因对比源码和反编译可以看出，都使用iterator进行迭代，差别在于foreach用list.remove(i)，iterator用iterator.remove()。执行在(Integer)iterator.next()抛出并发修改异常（见反编译代码），原因在于，next()中校验了Itr的expectedModCount和ArrayList的modCount需相等。list.remove(i)使list的modCount++，而iterator中的expectedModCount不变，由此产生差异。iterator.remove()会将list的modCount赋值给expectedModCount，无差异。 源码123456789101112131415161718public static void main(String[] args) &#123; List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4); for (Integer i : list) &#123; if (i.equals(1)) &#123; list.remove(i); &#125; &#125; Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) &#123; Integer i = iterator.next(); if (i.equals(3)) &#123; iterator.remove(); &#125; &#125;&#125; 执行异常信息1234Exception in thread &quot;main&quot; java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:907) at java.util.ArrayList$Itr.next(ArrayList.java:857) at com.jzt.service.joint.agent.ForEachTest.main(ForEachTest.java:18) IDE反编译12345678910111213141516171819202122public static void main(String[] args) &#123; List&lt;Integer&gt; list = Lists.newArrayList(new Integer[]&#123;1, 2, 3, 4&#125;); Iterator iterator = list.iterator(); Integer i; while(iterator.hasNext()) &#123; i = (Integer)iterator.next(); if (i.equals(1)) &#123; list.remove(i); &#125; &#125; iterator = list.iterator(); while(iterator.hasNext()) &#123; i = (Integer)iterator.next(); if (i.equals(3)) &#123; iterator.remove(); &#125; &#125;&#125; 附ArrayList中Itr源码节选1234567891011121314151617181920212223242526public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 删除倒数第二个元素不抛异常修改代码为remove 3，在迭代中输出元素，结果如下，foreach不会输出最后一个元素。list.remove(i)之后的hasNext()返回false，说明iterator的cursor与list的size相等。iterator.next()后，it.cursor = i + 1 = 3，it.lastRet = 2，指向元素3. list.remove((Integer)3)后，list.size = 3。 iterator.remove()执行的是remove(lastRet)，list.size = 3，修改cursor = lastRet = 2，指向元素4. 输出结果123456781231234 hasNext源码123456int cursor; // index of next element to return 下一个next返回int lastRet = -1; // index of last element returned; -1 if no such 上一个next返回 public boolean hasNext() &#123; return cursor != size;&#125;","tags":[]},{"title":"Java foreach原理","date":"2019-06-19T16:34:16.000Z","path":"2019/06/20/Java-foreach原理/","text":"从字节码可以看出，foreach使用了Iterator迭代器，循环判断hashNext()，用next()取操作对象。Collection接口继承了Iterable接口，可以获取iterator对象。【Iterator iterator();】集合对象有对应的xxIterator，实现具体的hashNext()、next()、remove()等操作。反编译源码更直观。 测试源码1234567891011public class ForEachTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); for (Integer i : list) &#123; System.out.println(i); &#125; &#125;&#125; IDE反编译源码1234567891011121314151617public class ForEachTest &#123; public ForEachTest() &#123; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList(); list.add(1); list.add(2); Iterator var2 = list.iterator(); while(var2.hasNext()) &#123; Integer i = (Integer)var2.next(); System.out.println(i); &#125; &#125;&#125; 字节码foreach部分节选 1234567891011121314151617181920212223242526 for (Integer i : list) &#123; System.out.println(i); &#125;L3 LINENUMBER 17 L3 ALOAD 1 INVOKEINTERFACE java/util/List.iterator ()Ljava/util/Iterator; (itf) ASTORE 2L4FRAME APPEND [java/util/List java/util/Iterator] ALOAD 2 INVOKEINTERFACE java/util/Iterator.hasNext ()Z (itf) IFEQ L5 ALOAD 2 INVOKEINTERFACE java/util/Iterator.next ()Ljava/lang/Object; (itf) CHECKCAST java/lang/Integer ASTORE 3L6 LINENUMBER 18 L6 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 3 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)VL7 LINENUMBER 19 L7 GOTO L4","tags":[]},{"title":"Java查看字节码","date":"2019-06-19T14:47:07.000Z","path":"2019/06/19/Java查看字节码/","text":"命令行方式编译成.class文件后，执行javap命令1javap -c xx.class idea安装bytecode viewer插件 切到.java文件所在tab，选择view-&gt;show bytecode","tags":[]},{"title":"ArrayList笔记","date":"2019-06-18T15:05:38.000Z","path":"2019/06/18/ArrayList笔记/","text":"Q&amp;A 为什么for中不能remove，而iterator时可以？见foreach中不宜进行remove/add等操作 迭代是怎么实现的？见Java foreach原理 关联知识 本质是数组 Object[] forEach(Consumer&lt;? super E&gt; action) action.accept(elementData[i]) 了解下Consumer，lambda removeIf(Predicate&lt;? super E&gt; filter) if (filter.test(element)) 要点扩容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /** * Default initial capacity. 默认容量 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. 指定容量为0时用到 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. 默认构造函数用到，容量为10 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit 受VM影响 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 右移，增加原容量两倍 if (newCapacity - minCapacity &lt; 0) // 还是比所需小，选所需 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果超过array最大值，尝试Intager最大值，不一定成功 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125; // minCapacity为size + 1 private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; 增还有add(int,E),addAll(collection&lt;&gt;)等重点是检查容量和扩容ensureCapacityInternal，在指定位置上赋值新元素 1234567891011/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 删 public E remove(int index) rangeCheck(index); 移动后续元素 最后元素赋值释放引用 public boolean remove(Object o) null和非null分开处理 fastRemove（与remove不同的是，无需rangeCheck） 改 public E set(int index, E element) rangeCheck;赋值；return old data 查 public E get(int index) rangeCheck;return elementData(index);123E elementData(int index) &#123; return (E) elementData[index];&#125; 一些源码的解惑batchRemove123456789101112131415161718192021222324252627282930private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) // 这里complement也很巧妙，removeAll把contains false的元素保留，retainAll把contains true的元素保留 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. // 此处是指contains抛出异常，r != size，需要把size-r个（没有被处理）的元素拷贝到w位置后 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; removeIf用了BitSet，filter test为真时，将该位BitSet设置为true 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) final E element = (E) elementData[i]; // filter test为真时，将该位BitSet设置为true if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; // 将值为false的元素保留（前移） i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; // 清除多余的空间，赋值null，去掉对对象的引用 for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; replaceAllUnaryOperator 一元操作 12345List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;list.replaceAll(x -&gt; x + 10); 123456789101112131415161718192021222324252627/** * Replaces each element of this list with the result of applying the * operator to that element. Errors or runtime exceptions thrown by * the operator are relayed to the caller. * @implSpec * The default implementation is equivalent to, for this &#123;@code list&#125;: * &lt;pre&gt;&#123;@code * final ListIterator&lt;E&gt; li = list.listIterator(); * while (li.hasNext()) &#123; * li.set(operator.apply(li.next())); * &#125; * &#125;&lt;/pre&gt; */@Override@SuppressWarnings(&quot;unchecked&quot;)public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 经常用到 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));","tags":[]},{"title":"java8 | lambda","date":"2019-05-17T18:08:53.000Z","path":"2019/05/18/java8-lambda/","text":"《Java8函数式编程》 [英] Richard Warburton 著，王群锋 译 人民邮电出版社 目录 简介 lambda表达式 流 类库 高级集合类和收集器 数据并行化 测试、调试和重构 设计和架构的原则 使用lambda编写并发程序 下一步 设计和架构的原则软件开发最重要的设计工具不是什么技术，而是一颗在设计原则方面训练有素的头脑。—— Craig Larman SOLID原则 Single responsibility 单一功能原则 Open/Closed 开闭原则 Liskov subsitution Interface segregation Dependency inversion 依赖反转","tags":[{"name":"lambda","slug":"lambda","permalink":"https://northernw.github.io/tags/lambda/"}]},{"title":"9. Palindrome Number | Easy","date":"2019-01-23T17:11:28.000Z","path":"2019/01/24/9-Palindrome-Number-Easy/","text":"leetCode: 9. Palindrome Number Description12345678910111213141516171819Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.Example 1:Input: 121Output: trueExample 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Example 3:Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:Coud you solve it without converting the integer to a string? SolutionFirst笨法子Runtime: 103 ms, faster than 68.27% of Java online submissions for Palindrome Number.1234567891011121314151617181920class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0)&#123; return false; &#125; StringBuilder sb = new StringBuilder(); while(x &gt; 0)&#123; sb.append(x%10); x/=10; &#125; String s = sb.toString(); int n = s.length(); for(int i=0;i&lt;n/2;i++)&#123; if(s.charAt(i)!=s.charAt(n-i-1))&#123; return false; &#125; &#125; return true; &#125;&#125; Recomended12345678910111213class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x!=0 &amp;&amp; x%10==0))&#123; return false; &#125; int reverse = 0; while(x&gt;reverse)&#123; reverse = reverse * 10 + x % 10; x/=10; &#125; return (x == reverse || x==reverse/10); &#125;&#125; Note","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]},{"title":"String to Integer (atoi) | Medium","date":"2019-01-23T16:43:49.000Z","path":"2019/01/24/String-to-Integer-atoi-Medium/","text":"leetCode: 8. String to Integer (atoi) Description1234567891011121314151617181920212223242526272829303132333435363738394041Implement atoi which converts a string to an integer.The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.If no valid conversion could be performed, a zero value is returned.Note:Only the space character &apos; &apos; is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.Example 1:Input: &quot;42&quot;Output: 42Example 2:Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42.Example 3:Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.Example 4:Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.Example 5:Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. SolutionFirst不是很喜欢这类题但是巧妙的解法还是很多啊 ref: leetcode discuss 12345678910111213141516171819202122232425262728class Solution &#123; public int myAtoi(String str) &#123; int sign = 1, i = 0, ans = 0, n=str.length(); if(n==0)&#123; return 0; &#125; // 这里的while和if都很巧妙 while(i&lt;n &amp;&amp; str.charAt(i)==&apos; &apos;)&#123; i++; &#125; if(i&lt;n &amp;&amp; (str.charAt(i)==&apos;-&apos; || str.charAt(i)==&apos;+&apos;))&#123; sign = 1 - 2*(str.charAt(i)==&apos;-&apos;?1:0); i++; &#125; int max = Integer.MAX_VALUE/10; // 这部分while直接忽略掉后续的不合法字符，也很赞 // 边界判断尾数&gt;&apos;7&apos;，对正负数都有效 // &quot;-2147483648&quot; &apos;8&apos;&gt;&apos;7&apos;，正好返回最小值 while(i&lt;n &amp;&amp; str.charAt(i)&gt;=&apos;0&apos; &amp;&amp; str.charAt(i)&lt;=&apos;9&apos;)&#123; if(ans&gt;max || (ans == max &amp;&amp; str.charAt(i)&gt;&apos;7&apos;))&#123; return sign==1?Integer.MAX_VALUE:Integer.MIN_VALUE; &#125; ans = ans * 10 + (str.charAt(i)-&apos;0&apos;); i++; &#125; return sign*ans; &#125;&#125; Note","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]},{"title":"ZigZag Conversion | Medium","date":"2019-01-23T14:51:08.000Z","path":"2019/01/23/ZigZag-Conversion-Medium/","text":"leetCode: 6. ZigZag Conversion Description123456789101112131415161718192021222324The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows);Example 1:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;Example 2:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I SolutionFirst心里想着是有数学规律的解答方案的，奈何数学太渣 Runtime: 56 ms, faster than 26.43% of Java online submissions for ZigZag Conversion. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows == 1) &#123; return s; &#125; int n = s.length(); int cnt = numRows + numRows - 2; int numCols = (n / cnt + 1) * (numRows - 1); char[][] flag = new char[numRows][numCols]; int i = 0, j = 0, k = 0; while (k &lt; n) &#123; flag[i][j] = s.charAt(k); k++; if (j % (numRows - 1) == 0) &#123; if (i == numRows - 1) &#123; i--; j++; &#125; else &#123; i++; &#125; &#125; else &#123; i--; j++; &#125; &#125; StringBuilder ans = new StringBuilder(); for (i = 0; i &lt; flag.length; i++) &#123; for (j = 0; j &lt; flag[i].length; j++) &#123; if (flag[i][j] != &apos;\\0&apos;) &#123; ans.append(flag[i][j]); &#125; &#125; &#125; return ans.toString(); &#125;&#125; RecommendedSort By Row[走Z方案]思路相同，写法可比自己的巧妙多了 34 ms goingDown的布尔比较巧妙 StringBuilder+List，节省空间，也省掉遍历1234567891011121314151617181920212223class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows == 1) return s; List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) rows.add(new StringBuilder()); int curRow = 0; boolean goingDown = false; for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; &#125; StringBuilder ret = new StringBuilder(); for (StringBuilder row : rows) ret.append(row); return ret.toString(); &#125;&#125; Visit By Row [找规律]传说中的数学方案每个循环的字符个数cycLen = 2*(numRows)-2，k为循环个数 0行的字符索引为 cycLen * k, k = 0,1,2… numRows-1行的字符索引为 cycLen * k + (numRows - 1), 比0行的索引加（numRows-1）个 其他每行，在每个循环中都有2个字符，索引分别为cycLenk+i和cycLen(k+1)-i，即cycLen*k+(cycLen-i) 总结起来 每行中都有一个索引cycLen * k + i 的字符 非0行和numRows-1行，还有一个 cycLen * k + (cycLen - i)的字符见下方实现 19 msj表示那一行内，位于竖着的那些列的字符所在索引即，[A] [S] [G]1234 P I N[A] L [S] I [G] Y A H R P I 12345678910111213141516171819202122class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows == 1) return s; int n = s.length(); int cyclen = numRows * 2 - 2; StringBuilder ans = new StringBuilder(); // i表示每行 // j表示每个分块 for(int i = 0; i &lt; numRows; i++)&#123; for(int j = 0; j+i &lt;n; j += cyclen )&#123; ans.append(s.charAt(j+i)); if(i!=0 &amp;&amp; i!= numRows-1 &amp;&amp; j+cyclen-i&lt;n)&#123; ans.append(s.charAt(j+cyclen-i)); &#125; &#125; &#125; return ans.toString(); &#125;&#125; Note","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]},{"title":"Longest Palindromic Substring | Medium","date":"2019-01-17T11:15:12.000Z","path":"2019/01/17/Longest-Palindromic-Substring-Medium/","text":"leetCode: 5. Longest Palindromic Substring DescriptionGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2: Input: “cbbd”Output: “bb” SolutionFirst原想暴力破解，想了下时间复杂度还是太高，看了hints决定提笔算。做的题都忘光光了，加油！ 145ms, faster than 20.90% of Java online submissions.仍需努力呀 Time complexity: O(n^2)Space complexity: O(n^2)12345678910111213141516171819202122232425262728293031class Solution &#123; public String longestPalindrome(String s) &#123; // Dynamic Programming int n = s.length(); boolean[][] flag = new boolean[n][n]; for(int len = 0; len &lt; n; len++)&#123; for(int i = 0; i&lt; n-len; i++)&#123; int start = i, end = i + len; if((start == end) || (start+1 == end))&#123; flag[start][end] = s.charAt(start) == s.charAt(end); &#125;else&#123; flag[start][end] = (s.charAt(start) == s.charAt(end)) &amp;&amp; flag[start+1][end-1]; &#125; &#125; &#125; int len = 0; String ans = &quot;&quot;; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(flag[i][j] &amp;&amp; (j-i+1 &gt; len))&#123; len = j-i+1; ans = s.substring(i,j+1); &#125; &#125; &#125; return ans; &#125;&#125; 优化了下，ans不在flag循环中取，还是145ms，大头仍是O(n^2)1234567891011121314int max = 0;int left = 0, right = 0;for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(flag[i][j] &amp;&amp; (j-i+1 &gt; max))&#123; max = j-i+1; left = i; right = j; &#125; &#125;&#125;return s.substring(left,right+1); Recomended最早想的方案也是这个，怎么就没想到有2n-1个中心呢没留意到偶数处理方案 16 ms, faster than 93.37% of Java online submissions.赞~时间复杂度还是O(n^2) Expand Around Center12345678910111213141516171819202122232425262728293031class Solution &#123; private int left = 0; private int len = 0; private int n = 0; public String longestPalindrome(String s) &#123; n = s.length(); if(n &lt; 2)&#123; return s; &#125; for(int i = 0; i &lt; n; i++)&#123; aroundCenter(s, i, i); aroundCenter(s, i, i+1); &#125; return s.substring(left, left+len); &#125; private void aroundCenter(String s, int start, int end)&#123; while(start&gt;=0 &amp;&amp; end &lt;n &amp;&amp; s.charAt(start)==s.charAt(end))&#123; start--; end++; &#125; // 此时start+1和end-1为正确下标，回文子串长度为(end-1)-(start+1)+1 if(end - start -1 &gt; len)&#123; left = start + 1; len = end - start -1; &#125; &#125;&#125; Compare做了个简单的对比输入字符串长约900字符平均 中心点法1ms，DP 20ms+ 原想对比dp两次for循环会增加多少时间，貌似不太准，作罢1234567891011@Testpublic void longestPalindrome() throws Exception &#123; LongestPalindromicSubstring longestPalindromicSubstring = new LongestPalindromicSubstring(); long start = System.currentTimeMillis(); System.out.println(longestPalindromicSubstring.longestPalindromeWithAroundCenter(s)); System.out.println(System.currentTimeMillis() - start); start = System.currentTimeMillis(); System.out.println(longestPalindromicSubstring.longestPalindromeWithDP(s)); System.out.println(System.currentTimeMillis() - start);&#125; Note dp找到状态转移方程，简单理解为递推公式 数组下标的计算，对数字不太敏感，笨 s[i,j], i与j中有j-i+1个元素 s[i]走j-i步到s[j]，因为s[i]本身占一个元素，再过j-i个元素","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]},{"title":"Longest Substring Without Repeating Characters | Medium","date":"2019-01-15T20:59:49.000Z","path":"2019/01/16/Longest-Substring-Without-Repeating-Characters-Medium/","text":"leetCode: 3. Longest Substring Without Repeating Characters DescriptionGiven a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3.Example 2: Input: “bbbbb”Output: 1Explanation: The answer is “b”, with the length of 1.Example 3: Input: “pwwkew”Output: 3Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. SolutionFirstTime Limit Exceeded 123456789101112131415161718192021class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ans = 1, len = s.length(); if(len == 0)&#123; return 0; &#125; Set&lt;Character&gt; set = new HashSet(); for(int left = 0; left &lt; len-1; left++)&#123; for(int right = left+1; right &lt; len; right++)&#123; set.clear(); for(int i = left; i &lt; right+1; i++)&#123; set.add(s.charAt(i)); &#125; if(right-left+1 == set.size() &amp;&amp; set.size() &gt; ans)&#123; ans = set.size(); &#125; &#125; &#125; return ans; &#125;&#125; RecommendedSliding Window123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; // sliding window int n = s.length(); int ans = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for(int i = 0, j = 0; i &lt; n &amp;&amp; j &lt; n; )&#123; // try to extend the range of [i, j] if(!set.contains(s.charAt(j)))&#123; ans = Math.max(ans, j - i +1); set.add(s.charAt(j++)); &#125;else&#123; set.remove(s.charAt(i++)); &#125; &#125; return ans; &#125;&#125; Sliding Window Optimized123456789101112131415161718class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; // sliding window optimized int n = s.length(); int ans = 0; // current index of character Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0, j = 0; j &lt; n; j++)&#123; // try to extend the range of [i, j] if(map.containsKey(s.charAt(j)))&#123; i = Math.max(i, map.get(s.charAt(j))); &#125; ans = Math.max(ans, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return ans; &#125;&#125; Note String substring(int,int) 左开右闭截取 charAt(int) 取char Set set = new HashSet&lt;&gt;(); 滑动窗解法，s[i,j)视为满足条件的子串，比较s[j]与s[i,j)，若满足条件，j++，若不满足条件，i++","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]},{"title":"Add Two Numbers | Medium","date":"2019-01-15T17:48:27.000Z","path":"2019/01/16/Add-Two-Numbers-Medium/","text":"leetCode: 2. Add Two Numbers DescriptionYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. SolutionFirst嗯，裹脚布，又臭又长12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; ListNode head = null; ListNode ans = new ListNode(0); while (l1 != null &amp;&amp; l2 != null) &#123; int sum = l1.val + l2.val + carry; if (sum &gt;= 10) &#123; carry = 1; sum %= 10; &#125; else &#123; carry = 0; &#125; ans.next = new ListNode(sum); ans = ans.next; if (head == null) &#123; head = ans; &#125; l1 = l1.next; l2 = l2.next; &#125; while (l1 != null) &#123; int sum = carry + l1.val; if (sum &gt;= 10) &#123; carry = 1; sum %= 10; &#125; else &#123; carry = 0; &#125; ans.next = new ListNode(sum); ans = ans.next; l1 = l1.next; &#125; while (l2 != null) &#123; int sum = carry + l2.val; if (sum &gt;= 10) &#123; carry = 1; sum %= 10; &#125; else &#123; carry = 0; &#125; ans.next = new ListNode(sum); ans = ans.next; l2 = l2.next; &#125; if (carry &gt; 0) &#123; ans.next = new ListNode(carry); &#125; return head; &#125;&#125; Betterref: (a 11-line cpp solution)[https://leetcode.com/problems/add-two-numbers/discuss/997/c%2B%2B-Sharing-my-11-line-c%2B%2B-solution-can-someone-make-it-even-more-concise] 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; ListNode ans = new ListNode(0); ListNode head = ans; ListNode zero = new ListNode(0); while (l1 != null || l2 != null || carry &gt; 0) &#123; if (l1 == null) &#123; l1 = zero; &#125; if (l2 == null) &#123; l2 = zero; &#125; int sum = l1.val + l2.val + carry; carry = sum / 10; ans.next = new ListNode(sum % 10); ans = ans.next; l1 = l1.next; l2 = l2.next; &#125; return head.next; &#125;&#125; Given Solution12345678910111213141516171819public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; Note","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]},{"title":"Reverse Integer | Easy | leetCode","date":"2019-01-14T14:58:20.000Z","path":"2019/01/14/Reverse-Integer-Easy-leetCode/","text":"leetCode: 7. Reverse Integer DescriptionGiven a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123Output: 321Example 2: Input: -123Output: -321Example 3: Input: 120Output: 21Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [-2^31, 2^31 - 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. SolutionFirst30ms12345678910111213141516171819class Solution &#123; public int reverse(int x) &#123; int res = 0; int tmp = x; boolean negtive = x &lt; 0; if(negtive)&#123; tmp = -tmp; &#125; while(tmp != 0)&#123; int carry = tmp % 10; if(res &gt; (Integer.MAX_VALUE - carry)/10)&#123; return 0; &#125; res = res *10 + carry; tmp /= 10; &#125; return negtive ? -res : res; &#125;&#125; Noteoverflow溢出Integer的最大值MAX_VALUE，最小值MIN_VALUE","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]},{"title":"Two Sum | Easy | leetCode","date":"2019-01-14T11:23:30.000Z","path":"2019/01/14/Two-Sum-Easy-leetCode/","text":"leetCode: 1.Two Sum DescriptionGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. SolutionFirst45ms1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; int i=0,j=0; for(;i&lt;len;i++)&#123; for(j=i+1; j&lt;len;j++)&#123; if(nums[i]+nums[j] == target)&#123; return new int[]&#123;i,j&#125;; &#125; &#125; &#125; return null; &#125;&#125; Better7ms123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(map.containsKey(target - nums[i]))&#123; return new int[]&#123;map.get(target - nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;0,0&#125;; &#125;&#125; Faster说是6ms.. 记录下123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(map.get(target - nums[i])!=null)&#123; return new int[]&#123;map.get(target - nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[]&#123;0,0&#125;; &#125;&#125; Note擅于利用map搜索","tags":[{"name":"leetCode","slug":"leetCode","permalink":"https://northernw.github.io/tags/leetCode/"}]}]