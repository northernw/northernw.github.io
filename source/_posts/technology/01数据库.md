---
title: 数据库
tags:
  - null
categories:
  - null
date: 2020-07-27 16:29:48
---

## MySql

###### 查询中哪些情况不会使用索引？

1. 使用or
2. like以"%xx"开始匹配
3. 联合（复合）索引，不符合最左匹配
4. 索引列数据类型隐形转换，比如列是字符串，但用数值来查询就用不上索引
5. 在where子句中，对索引列有数学运算、或者使用函数，用不了索引
6. MySQL估计全表扫描比查询索引快时（比如数据量非常少）



[MYSQL 索引类型、什么情况下用不上索引、什么情况下不推荐使用索引](https://blog.csdn.net/kaka1121/article/details/53395628)

[MySQL性能优化的最佳21条经验](https://www.cnblogs.com/hongfei/archive/2012/10/19/2731342.html) -- 没大用

[mysql explain执行计划详解](https://blog.csdn.net/kaka1121/article/details/53394426) -- 有错字之类的

type: const 命中唯一索引或主键的时候



###### 数据库隔离级别

1. 读未提交
2. 读提交
3. 可重复读
4. 可串行化



###### 数据库索引，底层是怎样实现的，为什么要用B+树索引？

MySQL底层使用B+树实现的。

MyISAM引擎，B+树主索引、辅助索引叶节点是数据记录的地址，称为非聚集索引（与InnoDB区分）

InnoDB的主键索引是聚集索引，叶节点存的完整的数据记录；辅助索引，叶节点存的是主键的值。



###### 为什么用B+树索引？

1. 数据文件比较大，一般存储在磁盘上

2. 索引的组织结构要尽量减少查找过程中磁盘IO次数。

3. 数据库系统利用磁盘预读原理，将一个节点的大小设为一个页的大小，则只需要一次IO就可以将一个节点的数据都读入

     

B+树只有叶子节点存放数据，非叶子节点作为索引，这样树出度大，树高小，一般3层，查询目标数据的io次数比较少，效率高。

使用节点大小正好等于磁盘一页大小的B+树，可以减少io操作次数，提高查询效率。



从数组、哈希表、二叉树等数据结构的对比来回答，见下面这篇文章

[MySQL为什么不用数组、哈希表、二叉树等数据结构作为索引呢](https://juejin.im/post/5e920646e51d4546f5790713)

[orderby底层执行过程](https://juejin.im/post/5e945b9651882573b7537c2a)



###### Mysql主从同步的实现原理？

原理：在主库上记录二进制日志，在备库重放日志的方式实现异步数据复制。

复制有三个步骤：

1. 主库记录二进制日志，每次准备提交事务（完成数据库更新）前先记录二进制日志（记录日志完后，再执行数据库更新）
2. 备库将主库的二进制文件复制到本地的中继日志中。
   1. 备库会启动一个工作线程，称为IO工作线程，负责和主库建立一个普通的客户端连接
   2. 如果该进程追赶上了主库，它将进入睡眠状态，直到主库有新的事件产生，会被唤醒，将接收到的事件记录到中继日志中
3. 备库的SQL线程读取中继日志并在备库执行
   1. 中继日志一般在系统缓存中，开销低，也可以根据配置选项来决定是否写入自己的二进制日志中



常见复制架构：

1. 一主多从

2. 主主

3. 环型复制

   ![wKioL1YKPpuzRxapAAKMyc9n3zQ218.jpg](/github/northernw.github.io/image/wKioL1YKPpuzRxapAAKMyc9n3zQ218.jpg)



[MySQL复制详解](https://blog.51cto.com/amyhehe/1699168)



###### MySQL是怎么用B+树？

innodb引擎用B+树当索引，索引文件同时是数据文件。聚集索引，也就是主键索引，叶节点存储的完整行数据；辅助索引，也称为非聚集索引，叶节点存对应行记录的主键。

MyISAM引擎也是用B+树当索引，为非聚集索引，索引不是数据文件，叶节点存的是行记录的地址。



###### 谈谈数据库乐观锁与悲观锁？

1. 悲观锁，认为操作会发生冲突，提前加锁，直到自己操作结束再释放锁。
2. MySQL的显式锁定 写锁 `select .. for update` & 读锁 `select .. lock in share mode`
3. 乐观锁，认为不会发生冲突，在提交更新的时候会判断一下期间数据有没有被修改。类似于CAS操作，常用方式有版本号、时间戳。





###### mvcc，怎么实现rr rc todo



###### mysql间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的sql语句，死锁发生了如何解决，mysql有没有提供什么机制去解决死锁

gap lock



###### MySQL几种常用的存储引擎区别

InnoDB与MyISAM比较典型的几个区别：

1. innodb支持事务、MVCC快照读、行级锁粒度、hash索引、聚集索引、支持外键
2. myisam支持全文索引、空间索引、数据压缩
3. innodb存储成本高、内存成本高、插入速度低，myisam反过来

来源：MySQL技术内幕

<img src="/github/northernw.github.io/image/image-20200515154754678.png" alt="image-20200515154754678" style="zoom:50%;" />

 



###### explain 可以看到哪些信息，什么信息说明什么，explain的结果列讲一下

https://dev.mysql.com/doc/refman/8.0/en/explain-output.html

| Column                                                       | JSON Name       | Meaning                                                      |
| ------------------------------------------------------------ | --------------- | ------------------------------------------------------------ |
| [`id`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id) | `select_id`     | The `SELECT` identifier     select标识                       |
| [`select_type`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type) | None            | The `SELECT` type    select类型                              |
| [`table`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table) | `table_name`    | The table for the output row    表名                         |
| [`partitions`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions) | `partitions`    | The matching partitions 使用的分区                           |
| [`type`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type) | `access_type`   | The join type  join类型                                      |
| [`possible_keys`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys) | `possible_keys` | The possible indexes to choose  可能使用的索引               |
| [`key`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key) | `key`           | The index actually chosen   实际使用的索引                   |
| [`key_len`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len) | `key_length`    | The length of the chosen key  实际使用的索引的长度           |
| [`ref`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref) | `ref`           | The columns compared to the index   与索引进行对比的列       |
| [`rows`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows) | `rows`          | Estimate of rows to be examined  预估要检查的行数            |
| [`filtered`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered) | `filtered`      | Percentage of rows filtered by table condition   符合条件的数据的百分比 |
| [`Extra`](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra) | None            | Additional information  额外的信息                           |

1. select_type

   常见的有SIMPLE（简单查询，无union、subqueries）、PRIMARY（子查询的外层）、SUBQUERY、UNION等

2. type

   1. system：表中只有一行数据，const的特殊情况

   2. const：至多有一行matching，可以理解为主键或唯一索引的=  （单表，对tbl_name来说，1是const）

      ```sql
      SELECT * FROM tbl_name WHERE primary_key=1;
      
      SELECT * FROM tbl_name
        WHERE primary_key_part1=1 AND primary_key_part2=2;
      ```

   3. eq_ref：主键或唯一索引的=   （多表关联，other_table的结果不定，所以对ref_table来说，选择不是const）

      ```sql
      SELECT * FROM ref_table,other_table
        WHERE ref_table.key_column=other_table.column;
      
      SELECT * FROM ref_table,other_table
        WHERE ref_table.key_column_part1=other_table.column
        AND ref_table.key_column_part2=1;
      ```

   4. ref：（非主键与非唯一索引的）其他索引的=和<=>（等和不等）

      ```sql
      SELECT * FROM ref_table WHERE key_column=expr;
      
      SELECT * FROM ref_table,other_table
        WHERE ref_table.key_column=other_table.column;
      
      SELECT * FROM ref_table,other_table
        WHERE ref_table.key_column_part1=other_table.column
        AND ref_table.key_column_part2=1;
      ```

   5. fulltext

      用到了全文索引

   6. ref_or_null

      类似ref，会额外检索包含null的行

   7. index_merge

      用到了多个索引，索引合并优化

   8. unique_subquery

      替换下面的in子查询，子查询返回不重复的集合

      ```sql
      value IN (SELECT primary_key FROM single_table WHERE some_expr)
      ```

   9. index_subquery

      区别于unique_subquery，用于非唯一索引，可以返回重复值

      ```sql
      value IN (SELECT key_column FROM single_table WHERE some_expr)
      ```

   10. range

       索引范围查找，包括主键、唯一索引、其他索引——即，所有key

        [`=`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal), [`<>`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal), [`>`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than), [`>=`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal), [`<`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than), [`<=`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than-or-equal), [`IS NULL`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-null), [`<=>`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to), [`BETWEEN`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between), [`LIKE`](https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like), or [`IN()`](https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in) 

       ```sql
       SELECT * FROM tbl_name
         WHERE key_column = 10;
       
       SELECT * FROM tbl_name
         WHERE key_column BETWEEN 10 and 20;
       
       SELECT * FROM tbl_name
         WHERE key_column IN (10,20,30);
       
       SELECT * FROM tbl_name
         WHERE key_part1 = 10 AND key_part2 IN (10,20,30);
       ```

   11. index

       类似all，但是只扫描索引，有两种情况

       1. 覆盖索引，select中的列都在索引中，extra中显示using index
       2. 利用索引的顺序进行全表扫描（比如有order by），extra中不宣誓using index

   12. all

       全表扫描

3. rows和filtered

   1. rows：MySQL认为需要检查的行数
   2. filtered：rows中会被过滤出来的——即符合条件的——的数据的百分比
   3. rows*filtered=查询出的结果数

4. extra 常见的有

   1. using index 列信息只从索引出，不用再从实际行取。使用了覆盖索引

   2. using where 没有可用的索引，通过where条件过滤

   3. using filesort 需要额外排序

   4. ....还有好多



###### 索引优化 todo 看看高性能书，有硬件层面和开发层面？

https://juejin.im/post/5b68e3636fb9a04fd343ba99#heading-3

1. 如果MySQL评估使用索引比全表扫描还慢，则不会使用索引

2. 前导模糊查询（like '%xx'）不会使用索引，可以优化为非前导模糊查询（like 'xx%'）

3. 数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来

4. 复合索引，要满足最左匹配原则

5. union、in、or 都能够命中索引，建议使用 in

   查询的CPU消耗：or (id=1 or id=2)> in (id in (1,2)) >union(id = 1 union id = 2)

6. 用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到

   因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加IO访问。

7. 负向条件查询不能使用索引，可以优化为 in 查询

   负向条件有：!=、<>、not in、not exists、not like 等。

8. 范围条件查询可以命中索引

   范围条件有：<、<=、>、>=、between等（返回数据的比例超过30%，会不使用索引）

9. 查询条件（带有计算函数）执行计算不会命中索引

10. 利用覆盖索引进行查询，避免回表

11. 建议索引的列设置为非null

12. 更新十分频繁的字段上不宜建立索引

13. 区分度不大的字段上不宜建立索引

14. 业务上具有唯一特性的字段，建议建立唯一索引

15. 多表关联时，关联字段建议有索引

16. 创建索引时避免以下错误观念

    1. 索引越多越好，认为一个查询就需要建一个索引。

    2. 宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度。

    3. 抵制唯一索引，认为业务的唯一性一律需要在应用层通过“先查后插”方式解决。

    4. 过早优化，在不了解系统的情况下就开始优化。



## 其他数据库

###### 有使用过哪些NoSQL数据库？MongoDB和Redis适用哪些场景？

工程中用过Redis，主要是小部分数据的缓存 其他不太了解

NoSql not only sql 非关系型数据库

[memcache、redis、mongoDB 如何选择？](https://zhuanlan.zhihu.com/p/32940868)



###### ~~Redis和memcache有什么区别？Redis为什么比memcache有优势？~~

不太了解



###### 考虑redis的时候，有没有考虑容量？大概数据量会有多少？

没有，公司维护的Redis组件 -- **redis & nosql 需要再深入一点呀**



###### Redis的缓存淘汰策略、更新策略

1. 过期策略

   1. 定期删除：默认每隔100ms随机抽取一些设置了过期时间的key，检查是否过期，如果过期就删除（因为全表扫描非常耗时、耗性能，所以是随机，也因此要配合惰性删除）
   2. 惰性删除：在客户端要获取某个key时，判断key是否设置过期以及是否过期，如果过期先删除

2. 内存淘汰策略

   Redis在使用内存达到某个阈值（通过maxmemory配置)的时候，就会触发内存淘汰机制，选取一些key来删除。

   ```shell
   # maxmemory <bytes> 配置内存阈值
   # maxmemory-policy noeviction 
   ```

   1. noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**默认策略**
   2. allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
   3. allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
   4. volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
   5. volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
   6. volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

   如何选取合适的策略？**比较推荐的是两种lru策略**。根据自己的业务需求。如果你使用Redis只是作为缓存，不作为DB持久化，那推荐选择allkeys-lru；如果你使用Redis同时用于缓存和数据持久化，那推荐选择volatile-lru。

   [redis过期策略和内存淘汰策略](https://juejin.im/post/5d8bf523e51d4577ff0d9e8c)

   [java实现LRU](https://www.cnblogs.com/lzrabbit/p/3734850.html)



###### redis的数据结构

[Redis基础](https://juejin.im/post/5db66ed9e51d452a2f15d833)

Redis 键值（Key-Value）存储数据库

1. string 字符类型
2. map 散列类型
3. list 列表类型
4. set 集合类型
5. sortedset 有序集合类型

###### redis如何实现分布式锁，zk如何实现分布式锁，两者的区别。如果service还没执行完，分布式锁在redis中已经过期了，怎么解决这种问题

redis实现分布式锁：setNX，创建成功表明获得了锁（要注意设置超时、谁加锁谁解锁、解锁的原子性）

zk实现分布式锁：在路径下创建临时顺序节点，序号最小的节点表示获得了锁，其他竞争者监听自己的前一个节点



redisson给的答案是锁获取成功后，注册一个定时任务，每隔一定时间(this.internalLockLeaseTime / 3L, 10s)就去续约

加一个监听器，如果key快要超时了，就进行续约（重置成30s）