---
title: 知识点汇总
tags:
  - null
categories:
  - null
date: 2020-04-07 21:15:01
---



1. 先是聊项目，从项目的架构设计到部署流程。

2. Java容器有哪些？哪些是同步容器,哪些是并发容器？

   容器分两个大类，Collection和Map。Collection又分List、Set、Queue、Vector几个大类，Map有HashMap、TreeMap、LinkedHashMap、HashTable，其中，Vector、HashTable是同步容器。

   并发容器一般在juc包下，有ConcurrentHashMap、CopyOnWriteArrayList等。

   ps:

   List: ArrayList、LinkedList

   Set: HashSet、LinkedHashSet、TreeSet

   Queue: LinkedList、PriorityQueue

   

   引申：几个容器的主要方法的操作流程，容器体系结构

   

3. ArrayList和LinkedList的插入和访问的时间复杂度？

   ArrayList：插入O(n) 访问O(1)

   LinkedList：插入O(1) 访问O(n)

   

4. Java反射原理， 注解原理？

   反射原理：在运行状态下，对于任何一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意方法和属性，并能改变它的属性。总结来说，反射把Java类中的各个成分映射成为一个个Java对象，并且可以进行操作。

   

   注解原理：注解的本质是一个继承了Annotation接口的接口。

   解析一个类或者方法的注解有两种形式，一是编译期扫描，如@Override，编译器会检查方法是否真的重写了父类的某个方法；二是运行期发射，虚拟机规范定义了一系列和注解相关的属性表，字段、属性或类上有注解时（被注解修饰了），会写相应信息进字节码文件，Class类中提供了一些接口用于获取注解或判断是否被某个注解修饰。

   延伸阅读：[JAVA 注解的基本原理](https://www.cnblogs.com/yangming1996/p/9295168.html)

   

   ps: Java类执行的过程/类加载过程（2-6）/类的生命周期（2-8） -- **tbc 更准确的说法**

   1. 编译：Java文件编译成.class字节码文件
   2. 加载：类加载器通过全限定名，将字节码加载进JVM，存储在方法区，将其转换为一个与目标类型对应的Class对象实例
   3. 验证：格式（.class文件规范）验证和语义（final不能继承等）验证？
   4. 准备：静态变量赋初值与内存空间，final修饰的内存空间直接赋原值（？），不是开发人员赋的初值
   5. 解析：符号引用转换为直接引用，分配地址（?）
   6. 初始化：先初始化父类，再初始化自身；静态变量赋值，静态代码块执行。
   7. 使用
   8. 卸载

   

5. 新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？

   新生代有三个区，一个较大的Eden区，两个小的Survivor区。

   使用复制算法。（也有标记过程，标记-复制）

   一方面，针对算法本身，相对于标记-清除算法，不会有内存碎片的问题；相对于标记-整理算法，处理效率高很多（在整理时，还未进行对象清理，移动存活对象时需要将存活对象插入到待清理对象之前，有大量的移动操作，时间复杂度很高）。

   复制算法主要问题在于内存利用率，而HotSpot的Eden和Survivor的默认比例是8:1，保证内存利用率达到了90%，所以影响也不是太大。

   另一方面，新生代minor gc比较频繁，对gc效率有比较高的要求；对象生命周期比较短，小的survivor空间即可容纳大部分情况下的存活对象。

   

   引申：jvm的几个知识点，算法，判断对象存活，GC roots有哪些，内存分配与回收策略，类加载机制

   

6. HashMap在什么情况下会扩容，或者有哪些操作会导致扩容？

   java8中

   1. 放入新值（putValue--put/putMapEntries）后，元素个数size大于阈值threshold，会触发扩容。
   2. 链表树化时，如果表长table.length小于64，会用扩容代替树化。
   3. put值前，如果表长为0，会触发扩容

   

7. HashMap put方法的执行过程？

   1. 如果table为空，或长度为0，初始化。默认loadFactor为0.75，默认capacity为16（capacity是table的长度），threshold一般为capacity*loadFactor。
   2. 通过hash定位槽，如果槽为空，构造新节点赋值给槽
   3. 若槽不为空，则在槽的链表或树中找到key相同的节点，替换节点值为新值；或是没有key相同的节点，就在树中或链表尾部加入新节点；若链表加入新节点后长度达到8（槽不算，aka槽下原有7个节点），则进行红黑树转化
   4. 如果是新加入节点，modCount、元素个数size自增1，如果元素个数超过阈值，则进行扩容

   

   7.1 Java8扩容的执行过程？

   

8. HashMap检测到hash冲突后，将元素插入在链表的末尾还是开头？

   Java8是加载链表末尾

   Java7是开头

   头插法会改变链表中元素原本的顺序，在并发情况下**可能**会产生链表成环的问题。

   Java7到Java8的改变[HashMap为何从头插入改为尾插入](https://blog.csdn.net/weixin_33919941/article/details/88031334)

   java7的问题[老生常谈，HashMap的死循环](https://www.jianshu.com/p/1e9cf0ac07f4)

   <img src="/github/northernw.github.io/image/IMG_2568.jpg" alt="IMG_2568" style="zoom:10%;" />

   

   

9. 1.8还采用了红黑树，讲讲红黑树的特性，为什么人家一定要用红黑树而不是AVL、B树之类的？

   插入、删除、查找的最坏时间复杂度都为 O(logn)。

   红黑树特性：

   1. 每个节点要么是黑色，要么是红色
   2. 根节点是黑色的
   3. 每个叶节点是黑色的（Java实现中，叶子节点是null，遍历时看不到黑色的叶子节点，反而每个叶子节点是红色的）
   4. 如果一个节点是红色的，那么它的两个子节点是黑色的（意味着可以有连续的黑色节点，但不能有连续的红色节点。若给定N个黑色节点，最短路径情况是连续N个黑色，树高为N-1；最长路径情况是红黑相间，树高为2N-2）
   5. 对任一节点，从节点到它每个叶子节点的路径包含相同数量的黑色节点（最主要特性，插入、删除要调整以遵守这个规则）

   [面试旧敌之红黑树（直白介绍深入理解）](https://juejin.im/entry/58371f13a22b9d006882902d)

   

   为什么用红黑树？

   红黑树的统计性能（理解为增删查平均性能）优于AVL树。

   AVL：名字来源发明者G. M. Adelson-Velsky和E. M. Landis。本质是平衡二叉搜索树（查找树），任何节点的左右子树高度差不超过1，是高度平衡的二叉查找树。

   B树：[重温数据结构：理解 B 树、B+ 树特点及使用场景](https://juejin.im/entry/5b0cb64e518825157476b4a9) 平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，**M 阶 B 树表示该树每个节点最多有 M 个子树**

   

   AVL树高度平衡，查找效率高，但维护这个平衡的成本比较大，插入、删除要做的调整比较耗时。

   红黑树的插入、删除、查找各种操作的性能比较平衡。

   B树和B+树多用于数据存储在磁盘上的场景，比较矮胖，一次读取较多数据，减少IO。节点内是有序列表。列表的插入、删除成本比较高，如果是链表形式，则查找效率比较低（不能用二分查找提高查询效率）。

   【自己的理解：B树节点内是有序列表，通过二分查找提高效率】

   为什么STL和linux都使用红黑树作为平衡树的实现？ - Acjx的回答 - 知乎 https://www.zhihu.com/question/20545708/answer/58717264

   

   

10. https和http区别，有没有用过其他安全传输手段？

   区别：

   1. http明文传输，安全性低；HTTPS数据加密传输，安全性高
   2. 使用https协议需要到CA（Certificate Authority，数字证书认证机构）申请证书
   3. http的响应速度比HTTPS快，因为HTTPS除了http三次握手的包，**还要加上ssl的交互**--具体是？
   4. 端口不同，http80端口，https443端口
   5. https本质是构建在ssl/tls之上的http协议

   [HTTP 与 HTTPS 的区别](https://www.runoob.com/w3cnote/http-vs-https.html)

   

   其他安全传输手段：SSH

   [SSH 协议原理、组成、认证方式和过程](https://www.jianshu.com/p/8e5b7aea52b5)

   

   延伸

   https的特性：加密保证安全性防窃听、认证防伪装、完整性防篡改

   加密方式：混合加密，用非对称加密传输对称秘钥，用对称秘钥进行要传输的数据的加解密

   认证：使用证书来对通信双方认证。

   完整性：ssl提供报文摘要功能来进行完整性保护。

   http也可以通过md5验证完整性，但数据篡改后也可重新生成md5，因为是明文的。https是通过ssl的报文摘要来保证完整性的，结合了加密与认证，即使加密后数据被篡改，也很难再生成报文摘要，因为不知道明文是什么。

   ![image-20200411180438085](/github/northernw.github.io/image/image-20200411180438085.png)

   

11. 线程池的工作原理，几个重要参数，然后给了具体几个参数分析线程池会怎么做，最后问阻塞队列的作用是什么？

    线程池解决两个问题：

    1. 由于减少了每个任务的调度开销，通常在执行大量异步任务时提供优秀的性能。
    2. 提供了管理、调控资源的方式

    

    Executors工厂方法：

    1. newFixedThreadPool 固定size的线程池。为了满足资源管理的需求，需要限制当前线程数量的场景。适用于负载比较重的服务器。
       1. corePoolSize == maximumPoolSize
       2. keepAliveTimes = 0
       3. LinkedBlockingQueue  队列大小Integer.MAX_VALUE，等价于无界
       4. 当线程池中线程数达到corePoolSize后，新任务将在队列中等待
       5. 由于使用无界队列，运行中的线程池不会拒绝任务
    2. newSingleThreadExecotor 单个线程的线程池。需要保证顺序执行任务的场景，并且在任意时间点不会有多个线程是活动的。
       1. corePoolSize = maximumPoolSize  = 1
       2. keepAliveTimes = 0
       3. LinkedBlockingQueue
       4. 如果当前线程池无线程，就创建一个线程来运行任务
       5. 当线程数达到1后，新的任务都加入到队列中
    3. newCachedThreadPool 大小无界的线程池（自动资源回收？），适用于有很多短期异步执行任务的小程序，或者是负载比较轻的服务器。
       1. corePoolSize = 0, maximumPoolSize = Integer.MAX_VALUE
       2. keepAliveTimes = 60s
       3. SynchronousQueue 是一个没有容量的阻塞队列，一个插入操作必须等待另一个线程对应的移除操作
       4. 提交任务时如果有空闲线程，就空闲线程取到这个任务执行；否则创建一个线程来执行任务
       5. 适用于将主线程的任务传递给空闲线程执行

    

    重要参数：

    1. core and maximum pool sizes 
       1. corePoolSize 核心最大线程：新任务加入时，如果运行线程个数小于核心线程数，即使有其他工作线程是空闲的，也会创建新线程 -- 线程池预热
       2. maximumPoolSize 线程池最大线程：阻塞队列满时，如果运行线程数小于maximumPoolSize，才可创建新线程运行任务
       3. corePoolSize=maximumPoolSize时，等价于newFixedThreadPool
       4. maximumPoolSize=本质上无限的数（比如Integer.MAX_VALUE），等价于newCachedThreadPool ？
       5. 一般只在构造时设置这两个参数，但也可以通过两个set方法改变
       6. **这两个参数会自动调整么？**
    2. On-demand construction
       1. 默认情况下，只有任务提交时才会创建线程（包括核心线程）
       2. 也可以通过prestartCoreThread或者prestartAllCoreTheads来预先创建线程。比如构建了一个阻塞队列不为空的线程池时，会想要这么做（预先创建线程）。
    3. Creating new threads
       1. 默认使用defaultThreadFactory来创建线程，相同的线程组ThreadGroup、优先级priority和非守护线程状态non-daemon status.
       2. 也可以使用自定义的threadFactory，自定义线程名称、线程组、优先级等。
       3. threadFactory创建线程失败的什么东西没看懂
    4. Keep-alive times
       1. keepAliveTime 如果线程数多于核心线程数，超过这个时间的空闲线程将会被停掉（指销毁掉？）
    5. queuing
       1. 入队规则
    6. rejected tasks 四个拒绝策略 RejectedExecutionHandler
       1. ThreadPoolExecutor.AbortPolicy 抛出RejectedExecutionException
       2. CallerRunsPolicy 调用者自身来执行
       3. DiscardPolicy 丢弃任务，任务不会被执行
       4. DiscardOldestPolicy work queue的首个任务将会被丢弃，重试添加当前任务（可能再次失败，自旋执行）
    7. hook methods
       1. beforeExecute afterExecute 可用来设置运行环境，重新初始化本地线程，获取统计数据，添加日志。
       2. terminated executor终止时提供的钩子方法
    8. queue maintenance getQueue可用于监控和调试当前work queue，其他用途不建议。remove和purge可用于大量任务取消时候的存储清理。
    9. reclamation （清除？）一个在程序中无引用、并且无剩余线程的线程池，即使无显式shutdown关闭，也可以被清除回收。可以通过这些方式设置线程池的线程在无使用时（最终）销毁：设置keep-alivet times；使用小的核心线程数比如0，或者设置allowCoreThreadTimeOut。

    

    ScheduledThreadPoolExcutor

    延迟运行命令，或周期执行命令

    

    LinkedBlockingQueue和DelayQueue的实现原理

    1. LinkedBlockingQueue 就是生产者消费者的实现
       1. 应用了ReentrantLock（putLock & tackLock）和lock的Condition（notEmpty & notFull）
    2. DelayQueue
       1. 应用了PriorityQueue，时间小的在队头
       2. ReentrantLock（lock）和Condition（available）

    

    FutureTask是用AQS实现的 get=acquireShared，run/cancel后=release

    

12. Linux怎么查看系统负载情况？

    1. uptime
    2. w
    3. top

    [查看linux系统负载情况](https://blog.csdn.net/xing1584114471/article/details/93385400)

    

13. 请详细描述springmvc处理请求全流程？

    <img src="/github/northernw.github.io/image/5-1ZG2095404c8.png" alt="Spring MVC工作原理图" style="zoom:50%;" />

    1. 通用的流程：

       1. 客户端提交请求到DispatcherServlet

       2. DispatcherServlet寻找Handler（HandlerExecutionChain）(包括handler , common interceptors和MappedInterceptor)

       3. DispatcherServlet调用controller

       4. controller调用业务逻辑，返回ModelAndView

       5. DispatcherServlet寻找ViewResolver，找到对应视图

       6. 渲染视图显示到客户端

          

    2. restful的一些细节（上述2、3、4过程的细化，restful的mav一般是空的）：

       1. getHandler取到一个HandlerExecutionChain mappedHandler，包含URL对应的controller方法HandlerMethod，和一些interceptors
       2. HandlerMethod取到对应的handlerAdapter，数据绑定就再这个ha中做的
       3. mappedHandler执行拦截器的preHandle
       4. handlerAdapter执行controller方法，包含请求前的数据绑定（数据转换），和请求后的数据转换（转换后将数据按需要的格式写入response）
       5. mappedHandler执行拦截器的postHandle
       6. 以上过程如果有抛出异常，由全局异常处理器来处理
       7. mappedHandler触发拦截器的afterCompletion
       8. 讲一讲AtomicInteger，为什么要用CAS而不是synchronized？

    

14. 查询中哪些情况不会使用索引？

    1. 使用or
    2. like以"%xx"开始匹配
    3. 联合（复合）索引，不符合最左匹配
    4. 索引列数据类型隐形转换，比如列是字符串，但用数值来查询就用不上索引
    5. 在where子句中，对索引列有数学运算、或者使用函数，用不了索引
    6. MySQL估计全表扫描比查询索引快时（比如数据量非常少）

    

    [MYSQL 索引类型、什么情况下用不上索引、什么情况下不推荐使用索引](https://blog.csdn.net/kaka1121/article/details/53395628)

    [MySQL性能优化的最佳21条经验](https://www.cnblogs.com/hongfei/archive/2012/10/19/2731342.html) -- 没大用

    [mysql explain执行计划详解](https://blog.csdn.net/kaka1121/article/details/53394426) -- 有错字之类的

    type: const 命中唯一索引或主键的时候

    

15. 数据库索引，底层是怎样实现的，为什么要用B+树索引？

    MySQL底层使用B+树实现的。

    MyISAM引擎，B+树主索引、辅助索引叶节点是数据记录的地址，称为非聚集索引（与InnoDB区分）

    InnoDB的主键索引是聚集索引，叶节点存的完整的数据记录；辅助索引，叶节点存的是主键的值。

    

    为什么用B+树索引？

    1. 数据文件比较大，一般存储在磁盘上

    2. 索引的组织结构要尽量减少查找过程中磁盘IO次数。

    3. 数据库系统利用磁盘预读原理，将一个节点的大小设为一个页的大小，则只需要一次IO就可以将一个节点的数据都读入

       

    B+树只有叶子节点存放数据，非叶子节点作为索引，这样树出度大，树高小，一般3层，查询目标数据的io次数比较少，效率高。

    使用节点大小正好等于磁盘一页大小的B+树，可以减少io操作次数，提高查询效率。

    

    [MySQL为什么不用数组、哈希表、二叉树等数据结构作为索引呢](https://juejin.im/post/5e920646e51d4546f5790713)

    [orderby底层执行过程](https://juejin.im/post/5e945b9651882573b7537c2a)

    

16. Mysql主从同步的实现原理？

    原理：在主库上记录二进制日志，在备库重放日志的方式实现异步数据复制。

    复制有三个步骤：

    1. 主库记录二进制日志，每次准备提交事务（完成数据库更新）前先记录二进制日志（记录日志完后，再执行数据库更新）
    2. 备库将主库的二进制文件复制到本地的中继日志中。
       1. 备库会启动一个工作线程，称为IO工作线程，负责和主库建立一个普通的客户端连接
       2. 如果该进程追赶上了主库，它将进入睡眠状态，直到主库有新的事件产生，会被唤醒，将接收到的事件记录到中继日志中
    3. 备库的SQL线程读取中继日志并在备库执行
       1. 中继日志一般在系统缓存中，开销低，也可以根据配置选项来决定是否写入自己的二进制日志中

    

    常见复制架构：

    1. 一主多从

    2. 主主

    3. 环型复制

       ![wKioL1YKPpuzRxapAAKMyc9n3zQ218.jpg](/github/northernw.github.io/image/wKioL1YKPpuzRxapAAKMyc9n3zQ218.jpg)

    

    

    

    [MySQL复制详解](https://blog.51cto.com/amyhehe/1699168)

17. MySQL是怎么用B+树？

    innodb引擎用B+树当索引，索引文件同时是数据文件。聚集索引，也就是主键索引，叶节点存储的完整行数据；辅助索引，也称为非聚集索引，叶节点存对应行记录的主键。

    MyISAM引擎也是用B+树当索引，为非聚集索引，索引不是数据文件，叶节点存的是行记录的地址。

    

18. 谈谈数据库乐观锁与悲观锁？

    1. 悲观锁，认为操作会发生冲突，提前加锁，直到自己操作结束再释放锁。
      
    1. MySQL的显式锁定 写锁 `select .. for update` & 读锁 `select .. lock in share mode`
      
    2. 乐观锁，认为不会发生冲突，在提交更新的时候会判断一下期间数据有没有被修改。类似于CAS操作，常用方式有版本号、时间戳。

       

19. 有使用过哪些NoSQL数据库？MongoDB和Redis适用哪些场景？

    工程中用过Redis，主要是小部分数据的缓存 其他不太了解

    NoSql not only sql 非关系型数据库

    

    [memcache、redis、mongoDB 如何选择？](https://zhuanlan.zhihu.com/p/32940868)

    

20. 描述分布式事务之TCC服务设计？

    1. 不了解

    2. [TCC分布式事务](https://www.cnblogs.com/jajian/p/10014145.html) try - confirm - cancel

       

21. Redis和memcache有什么区别？Redis为什么比memcache有优势？

    同19

22. 考虑redis的时候，有没有考虑容量？大概数据量会有多少？

    没有，公司维护的Redis组件 -- **redis & nosql 需要再深入一点呀**

    

23. 谈谈分布式锁、以及分布式全局唯一ID的实现比较？

    分布式锁

    1. 为什么需要分布式锁？

       1. 效率：避免不同节点重复相同的工作，这些工作会浪费资源。比如针对一个操作发多封邮件。
       2. 正确性：避免破坏正确性的发生，比如多个节点操作了同一条数据，其中一个操作结果被覆盖了，造成数据丢失。

    2. 常见实现方式

       1. 数据库
          1. 表的一行数据表示一个资源，`select..for update`来加锁，可同时存节点信息，支持重入。
          2. 理解简单，但需要自己实现，以及维护超时、事务和异常处理等，性能局限于数据库，性能相对比较低，不适合高并发场景。
       2. zookeeper
          1. curator封装 -- 具体怎么用还没看过呢
          2. Zk 排他锁和共享锁有区别。排他锁，利用zk有序节点，序号最小的节点表示获取到锁，其他未获取到锁的节点监听自己的前一个节点。 （共享锁，能获取到资源都算？回家再看看。）还有个读写锁，一个节点获取读锁，只要序号小于他的都为读锁，就表示获取到读锁；一个节点获取写锁，需要自己的序号最小，才表示获取到写锁。可重入锁之类的，zk节点写值吧，原理和Java的reentrantLock类似，获取多少次，state自加多少次，解锁再一次次自减，直到state为0表示完全释放。
          3. （文章里说zk分布式锁和数据库mysql差不多。。真的么）
       3. redis setNX
          1. 自己参照一篇文章实现的比较简单，主要利用setNX，不支持重入，非公平。有超时释放，有加锁身份，解锁原子性
          2. 下面的文章里介绍的Redission。不太了解，加锁原子性lua脚本，用了hset，hashmap的结构，key是资源，value是锁定次数，可重入。。还有公平锁的实现。。。

       [分布式锁](https://juejin.im/post/5bbb0d8df265da0abd3533a5)

       

    

    分布式全局唯一ID/分布式ID生成器 实现方式

    1. 数据库自增主键

    2. ...

       

    

24. 集群监控的时候，重点需要关注哪些技术指标？这些指标如何优化？

    1. 系统指标：cpu使用率、内存使用率、机器连通性、系统负载（cpu.load）
    2. 网络指标：网络流入速度、网络流出速度、网络流入包数、网络流出包数、TCP连接数、TCP Active Opens（主动打开数）、IP接收包数、IP丢包数、TCP接收包数、TCP发送包数、TCP包传输错误数、TCP重传数
    3. 磁盘指标：磁盘使用率、iNode使用率、磁盘繁忙占比、磁盘读速度、磁盘写速度、磁盘读次数、磁盘写次数
    4. 容器指标？：线程数[容器指标]/平均到每核、进程数[容器指标]/平均到每核....

    [监控知识体系](https://zhuanlan.zhihu.com/p/26369145)

    [小米监控](https://book.open-falcon.org/zh_0_2/intro/)

25. 从千万的数据到亿级的数据，会面临哪些技术挑战？你的技术解决思路？

    

26. 最近两年遇到的最大的挫折，从挫折中学到了什么？

27. 最近有没有学习过新技术？

28. 简单说一下面向对象的特征以及六大原则

29. 谈谈final、finally、finalize的区别

30. Java中==、equals与hashCode的区别和联系

31. 谈谈Java容器ArrayList、LinkedList、HashMap、HashSet的理解，以及应用场景

32. 谈谈线程的基本状态，其中的wait() sleep() yield()方法的区别。

33. JVM性能调优的监控工具了解那些？

34. 简单谈谈JVM内存模型，以及volatile关键字

35. 垃圾收集器与内存分配策略

36. 垃圾收集算法

37. MySQL几种常用的存储引擎区别

38. 数据库的隔离级别

39. 5亿整数的大文件，怎么排？

40. Java内存模型

41. full gc怎么触发？

42. gc算法

43. JVM回收策略

44. ClassLoader原理和应用

45. 高吞吐量的话用哪种gc算法

46. ConcurrentHashMap和HashMap

47. volatile的底层如何实现，怎么就能保住可见性了？

48. 有参与过开源的项目吗？

49. 线程池原理，拒绝策略，核心线程数

50. 1亿个手机号码，判断重复

51. 线程之间的交互方式有哪些？有没有线程交互的封装类 （join）？

52. 两次点击，怎么防止重复下订单？

53. 数据库表设计，索引

54. Redis的缓存淘汰策略、更新策略

55. dubbo、netty、RPC介绍原理

56. 限流算法

57. zk挂了怎么办？

58. 分布式锁的实现方式，zk实现和Redis实现的比较

59. 秒杀场景设计，应付突然的爆发流量

60. 分布式数据一致性

61. 一致性哈希

62. 消息队列原理介绍

63. 注解的原理

64. 数据库原理，数据库中间件，索引优化

65. ioc原理、aop原理和应用

66. 大数据相关，MapReduce

67. Docker的原理

68. Http协议

69. cookie session介绍一下

70. session表结构怎么设计，储存在哪里？

71. 你们的session cookie在项目里运用到哪里？

72. 算法题：[删除链表中重复的节点]在一个排序的链表中,存在重复的节点,请删除该链表中重复的节点,重复的节点不保留,返回链表头指针.例如,链表1-2-3-3-4-4-5处理后为1-2-5

73. TCP/UDP的区别介绍一下

74. TCP如何保证传输的有效性。

75. TCP的拥塞控制

76. TCP建立连接的三次握手

77. TCP四次挥手断开连接

78. Java的锁机制

79. 死锁产生的原因

80. 三次握手和四次挥手,time_wait是什么状态

81. B树 B+树区别说一下

82. 数据库平时用到过什么 咱们先问MySQL MySQL索引原理知道吗，问了两种索引的区别

83. 索引的分类和优缺点

84. innodb和myisam的区别

85. 乐观锁悲观锁区别说一下

86. 数据库四种隔离状态 分别有什么问题

87. redis的数据结构

88. sortset底层，原理，怎么保证有序

89. 冯诺依曼计算机的结构

90. 操作系统的虚拟内存

91. 进程的调度

92. 进程间的通讯方式

93. 线程间的同步方式

94. 进程和线程的区别

95. 常见的排序算法