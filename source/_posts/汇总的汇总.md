---
title: 汇总的汇总
tags:
  - null
categories:
  - null
date: 2020-07-23 13:53:59
---



# 数据库







# Java

## Java基础

###### Java反射原理， 注解原理？

反射原理：在运行状态下，对于任何一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意方法和属性，并能改变它的属性。总结来说，反射把Java类中的各个成分映射成为一个个Java对象，并且可以进行操作。



注解原理：注解的本质是一个继承了Annotation接口的接口。

解析一个类或者方法的注解有两种形式，一是编译期扫描，如@Override，编译器会检查方法是否真的重写了父类的某个方法；二是运行期发射，虚拟机规范定义了一系列和注解相关的属性表，字段、属性或类上有注解时（被注解修饰了），会写相应信息进字节码文件，Class类中提供了一些接口用于获取注解或判断是否被某个注解修饰。

延伸阅读：[JAVA 注解的基本原理](https://www.cnblogs.com/yangming1996/p/9295168.html)



ps: Java类执行的过程/类加载过程（2-6）/类的生命周期（2-8） -- **tbc 更准确的说法**

1. 编译：Java文件编译成.class字节码文件
2. 加载：类加载器通过全限定名，将字节码加载进JVM，存储在方法区，将其转换为一个与目标类型对应的Class对象实例
3. 验证：格式（.class文件规范）验证和语义（final不能继承等）验证？
4. 准备：静态变量赋初值与内存空间，final修饰的内存空间直接赋原值（？），不是开发人员赋的初值
5. 解析：符号引用转换为直接引用，分配地址（?）
6. 初始化：先初始化父类，再初始化自身；静态变量赋值，静态代码块执行。
7. 使用
8. 卸载



## Java容器

###### 1. Java容器有哪些？哪些是同步容器,哪些是并发容器？

容器分两个大类，Collection和Map。Collection又分List、Set、Queue、Vector几个大类，Map有HashMap、TreeMap、LinkedHashMap、HashTable，其中，Vector、HashTable是同步容器。

并发容器一般在juc包下，有ConcurrentHashMap、CopyOnWriteArrayList等。

ps:

List: ArrayList、LinkedList

Set: HashSet、LinkedHashSet、TreeSet

Queue: LinkedList、PriorityQueue



引申：几个容器的主要方法的操作流程，容器体系结构



###### 2. ArrayList和LinkedList的插入和访问的时间复杂度？

ArrayList：插入O(n) 访问O(1)

LinkedList：插入O(1) 访问O(n)



## Java并发





## Java虚拟机

###### 新生代分为几个区？使用什么算法进行垃圾回收？为什么使用这个算法？

新生代有三个区，一个较大的Eden区，两个小的Survivor区。

使用复制算法。（也有标记过程，标记-复制）

一方面，针对算法本身，相对于标记-清除算法，不会有内存碎片的问题；相对于标记-整理算法，处理效率高很多（在整理时，还未进行对象清理，移动存活对象时需要将存活对象插入到待清理对象之前，有大量的移动操作，时间复杂度很高）。

复制算法主要问题在于内存利用率，而HotSpot的Eden和Survivor的默认比例是8:1，保证内存利用率达到了90%，所以影响也不是太大。

另一方面，新生代minor gc比较频繁，对gc效率有比较高的要求；对象生命周期比较短，小的survivor空间即可容纳大部分情况下的存活对象。



引申：jvm的几个知识点，算法，判断对象存活，GC roots有哪些，内存分配与回收策略，类加载机制





## Java IO

