---
title: 知识点汇总3
tags:
  - null
categories:
  - null
date: 2020-05-31 14:03:50
---

70. ioc原理、aop原理和应用

    1. ioc原理 控制反转（依赖注入）
       1. 本质是，spring维护了一个实例的容器，在需要使用某个实例的地方，自动注入这个实例
       2. 主要运用了反射机制，通过反射来创建约定的实例，并维护在容器中
       
    2. aop原理 面向切面编程
      
       [AOP原理](https://juejin.im/post/5bf4fc84f265da611b57f906)
       
       1. 原理是动态代理。代理模式的定义：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。实现方式：
       
          1. 首先有接口A，类a实现接口A
       
          2. 接着创建一个bInvocationHandler类，实现InvocationHandler接口，持有一个被代理对象的实例target，invoke方法中触发method
       
             ```java
                 /**
                  * proxy: 代表动态代理对象，编译时候生成的
                  * method：代表正在执行的方法
                  * args：代表调用目标方法时传入的实参
                  */
                 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                     System.out.println("代理执行" +method.getName() + "方法");
                     Object result = method.invoke(target, args);
                     return result;
                 }
             ```
       
          3. 创建代理对象
       
             ```
             A a = (A) Proxy.newProxyInstance(A.class.getClassLoader(), new Class<?>[]{A.class}, handler)
             ```
       
             ![image-20200601110636533](/github/northernw.github.io/image/image-20200601110636533.png)
       
       2. 比如日志、监控等公共行为可以通过AOP来实现，避免大量重复代码
       
       3. 元素
       
          1. 切面：拦截器类，定义切点以及通知
          2. 切点：具体拦截的某个业务点
          3. 通知：切面当中的方法，声明通知方法在目标业务层的执行位置，通知类型如下：
             1. 前置通知：@Before 在目标业务方法执行之前执行
             2. 后置通知：@After 在目标业务方法执行之后执行
             3. 返回通知：@AfterReturning 在目标业务方法返回结果之后执行
             4. 异常通知：@AfterThrowing 在目标业务方法抛出异常之后
             5. 环绕通知：@Around 功能强大，可代替以上四种通知，还可以控制目标业务方法是否执行以及何时执行
       
       4. aspectj切面扫描的细节再看下

65. ~~大数据相关，MapReduce~~ 不考虑

66. Docker的原理【待看】

    [Docker核心技术与实现原理](http://www.dockone.io/article/2941)

    [Docker底层原理介绍](https://www.jianshu.com/p/e1f7b8d5184c)

67. Http协议

    1. 基础概念

       1. URI：uniform resource identifier 统一资源标识符

          1. URL：uniform resource locator 统一资源定位符
          2. URN：uniform resource name 统一资源名称
          3. URI包括URL和URN

       2. 请求报文的格式

          1. request line 请求行：请求方法，URL，协议

          2. request headers 请求头：各种header

          3. 请求行和请求头合称为**请求消息头**

          4. 空行分隔开请求头和请求消息体

          5. request message body **请求消息体**：key-value形式或者raw格式等等

             ![image-20200531143718430](/github/northernw.github.io/image/image-20200531143718430.png)

       3. 响应报文的格式

          1. status line 状态行：协议，状态码

          2. response headers 响应头

          3. 状态行和响应头合称为响应消息头

          4. 空行分隔开消息头和消息体

          5. response message body 响应消息体

             ![image-20200531143732598](/github/northernw.github.io/image/image-20200531143732598.png)

    2. HTTP方法

       1. get 主要用来获取资源
       2. head 获取报文首部，主要用于确认 URL 的有效性以及资源更新的日期时间等。
       3. post 主要用来传输数据
       4. put 上传文件，不带验证机制存在安全问题，一般不使用
       5. patch 对资源进行部分修改 -- 也不常用
       6. delete 删除文件，与put功能相反，同样不带验证机制
       7. options 查询支持的方法，会返回`Allow: GET, POST, HEAD, OPTIONS`这样的内容
       8. connect 要求在与代理服务器通信时建立隧道。使用 SSL(Secure Sockets Layer，安全套接层)和 TLS(Transport Layer Security，传输层安全)协议把通信内容 加密后经网络隧道传输。
       9. trace 追踪路径，一般也不用...

    3. HTTP状态码

       简要记一下

       1. 1XX 信息性状态码，接收的请求正在处理
       2. 2XX 请求正常处理完毕
       3. 3XX 重定向
       4. 4XX 客户端错误
       5. 5XX 服务端错误

    4. 再关注下前面的http和HTTPS的比较

       

68. cookie session介绍一下

    1. cookie

       1. 是服务器发送到用户浏览器并保持在本地的一小块数据，会在浏览器向同一服务器再次发起请求时被带上。
       2. 用途：
          1. 会话状态管理（比如用户登录状态、购物车等）
          2. 个性化设置（比如用户自定义设置、主题等）
          3. 浏览器行为分析
       3. 生成方式
          1. 服务器发送`Set-Cookie: yummy_cookie=choco`这样的header，客户端得到响应报文后把cookie存在浏览器
          2. 浏览器通过`document.cookie`属性可创建新的cookie
       4. HttpOnly 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。
       5. Secure 标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信 息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。

    2. session

       1. 存储在服务端，可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中
       2. 使用 Session 维护用户登录状态的过程如下:
          1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中; 
          2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID; 
          3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中;
          4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取 出用户信息，继续之前的业务操作。

    3. cookie和session的选择

       1. cookie只能存储ASCII码字符串，session可以存储任何类型的数据

       2. cookie存储在浏览器中，安全性较低

       3. 对于大型网址，如果所有用户信息都存储在session中，开销比较大 -- 【感觉不是个问题...】

          

69. session表结构怎么设计，储存在哪里？

    1. 我们项目里没有直接使用session，用的是商城统一单点登录
    2. 
    3. 如果我设计
       1. 首先一个用户请求过来，如果没有带session id，先重定向到登录页
       2. 收到登录请求，身份验证通过后，生成一个session，key为唯一ID，即session id，value为需要存储的信息，比如用户名、生成时间等，将session id作为cookie响应发回浏览器
       3. 众多的session是key-value结构，session本身也是key-value结构
       4. 存储在Redis

70. 你们的session cookie在项目里运用到哪里？

    1. session是SSO用的，cookie也主要是SSO用的
    2. 偶尔用的cookie是虚拟登录这样的场景
       1. 比如超级账号：员工的erp账号以只读的形式登录到用户账号，主要用于排查问题
       2. 比如账号管家：系统中，账号体系中的主账号可以登录到子账号上，一般也只读
       3. 再如虚拟登录，业务范畴上，两个账号建立授权关系，B账号可以虚拟登录到A账号上，代为操作系统
       4. 实现：被登录人一般是sso中的session对应的用户，属于资源所属者；操作者是erp账号、主账号、虚拟登录账号等，会有登录类型区分，这些信息会先加密，再存入cookie中（还会有不同的拦截器，进行身份和权限验证）

77. 单点登录的实现

    1. CAS

       TGT：Ticket Granted Ticket（俗称大令牌，或者说票根，他可以签发ST）。【类似session】

       TGC：Ticket Granted Cookie（cookie中的value），存在Cookie中，根据他可以找到TGT。【类似session id】

       ST：Service Ticket （小令牌），是TGT生成的，默认是用一次就生效了。也就是上面的ticket值。

       ps: 未登录状态下，访问app1时，展示登录页，浏览器会写入cas服务器的TGC；第二次访问app2，（因为app2本身校验当前请求未登录）重定向到cas服务器时，会带上TGC，cas服务器根据TGC判断用户已登录，签发新的ST再重定向到app2，这时候app2用ST校验通过，记录下自己的session cookie，提供请求内容。

       ![img](/github/northernw.github.io/image/167772fc86501755.png)

    2. ~~OAuth~~ 【不看了不看了！】

       https://juejin.im/post/5cc81d5451882524f72cd32c

       https://juejin.im/post/5b3b3b61f265da0f955ca780

       <img src="/github/northernw.github.io/image/image-20200601201126291.png" alt="image-20200601201126291" style="zoom:50%;" />

       <img src="/github/northernw.github.io/image/image-20200601201230467.png" alt="image-20200601201230467" style="zoom:50%;" />
       
       

78. 算法题：[删除链表中重复的节点]在一个排序的链表中,存在重复的节点,请删除该链表中重复的节点,重复的节点不保留,返回链表头指针.例如,链表1-2-3-3-4-4-5处理后为1-2-5

    

79. TCP/UDP的区别介绍一下

    1. UDP：用户数据报协议 UDP(User Datagram Protocol)是无连接的，尽最大可能交付，没有拥塞控制，面向报文 (对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)，支持一对一、一对多、多对一和多对多 的交互通信。

    2. TCP：传输控制协议 TCP(Transmission Control Protocol)是面向连接的，提供可靠交付，有流量控制，拥塞控 制，提供全双工通信，面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据 块)，每一条 TCP 连接只能是点对点的(一对一)。

    3. UDP首部格式

       首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

       <img src="/github/northernw.github.io/image/image-20200602195522814.png" alt="image-20200602195522814" style="zoom:50%;" />

    4. TCP首部格式

       <img src="/github/northernw.github.io/image/image-20200602195629503.png" alt="image-20200602195629503" style="zoom:50%;" />

       1. 序号 :用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。

       2. 确认号 :期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据 长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。

       3.  数据偏移 :指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。

       4. 确认 ACK :当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

       5. 同步 SYN :在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建 立连接，则响应报文中 SYN=1，ACK=1。

       6. 终止 FIN :用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 

       7. 窗口 :窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空 间是有限的。

          

80. TCP如何保证传输的有效性。

    使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

    

81. TCP滑动窗口

    1. 暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小。

    2. 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态;接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

    3. 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前 的所有字节都已经被接收。

       ![image-20200602202005619](/github/northernw.github.io/image/image-20200602202005619.png)

    

82. TCP的拥塞控制

    1. 与**流量控制**的区别：

       1. 流量控制是上一题里窗口，接收方发送窗口值来控制发送方的窗口大小，从而影响发送方的发送速率。将窗口值设置为0，则发送方不能发送数据。
        2. 控制发送方的发送速率，保证接收方来得及接收。

    2. **拥塞控制**

       1. 是为了降低整个网络的拥塞程度

       2. 主要通过四个算法进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

       3. 发送方需要维护一个叫做拥塞窗口(cwnd)的状态变量（只是一个状态变量，不是发送方窗口。再区别一下，拥塞窗口讨论的是报文段数量，发送窗口讨论的是字节数量）

       4. **慢开始与拥塞避免**

          1. 发送的最初是慢开始，cwnd=1，发送方只能发送一个报文段；接收到确认后，将cwnd加倍，之后能发送的报文段数量是2、4、8..

          2. ssthresh是慢开始门限（初始值自己定），当cwnd >= ssthresh 时，进入拥塞避免，每个轮 次只将 cwnd 加 1。

          3. 如果出现超时，则另ssthresh = cwnd / 2，并重新执行慢开始。

          4. 见图1、2、3

             ![image-20200602203232342](/github/northernw.github.io/image/image-20200602203232342.png)

       5. 快重传与快恢复

          1. 【在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。】

          2. 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。【例如收到三个 M2，则 M3 丢失，立即重传 M3。】

          3. 同时执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，并直接进入拥塞避免。

          4. 见上图4、5

             ![image-20200602203554747](/github/northernw.github.io/image/image-20200602203554747.png)

             

83. TCP建立连接的三次握手

    假设A为客户端，B为服务端

    1. 首先B处于监听（listen）状态，等待客户的连接请求
    2. A向B发送**连接（SYN，同步）请求报文**，SYN=1，ACK=0，seq=x（选择一个初始的序号x）
    3. B收到连接请求报文，如果同意建立连接，则向A发送**连接确认报文**，SYN=1，ACK=1，ack=x+1（确认号为x+1），seq=y（同时也选择一个初始的序号y）
    4. A收到B的连接确认报文后，还要向B发出确认，seq=x+1（序号为x+1），ack=y+1（确认号为y+1）

    为什么要三次握手？

    三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

    客户端发送的连接请求如果在网络中滞留，那么隔很长时间才能收到服务器发回的连接确认，在这段时间内，客户端等待一个超时重传时间后，就会重新发送连接请求。同时滞留的连接请求最后还是会到达服务器，如果只是两次握手，那么服务器会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

    ![image-20200603103804834](/github/northernw.github.io/image/image-20200603103804834.png)

84. TCP四次挥手断开连接

    ack都为1.

    1. A 发送连接释放报文，FIN=1。

    2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 

    3. 当 B 不再需要连接时，发送连接释放报文，FIN=1。

    4. A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL(最大报文存活时间)后释放连接。

    5. B 收到 A 的确认后释放连接。

    **四次挥手的原因**

    客户端发送FIN连接释放报文后，服务器收到这个报文就进入**CLOSE_WAIT**状态，这个状态是为了让服务器端发送未传送完毕的数据，发完后服务器就会发送FIN连接释放报文。  

     **TIME_WAIT**

    客户端收到服务端的FIN报文后进入此状态，并不是直接进入CLOSED状态，还需要等待一个时间计时器设置的时间2MSL。有两个理由：

    1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文， A 等待一段时间就是为了处理这种情况的发生。
    2. 等待一段时间是为了让本次连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

    ![image-20200603124530763](/github/northernw.github.io/image/image-20200603124530763.png)

85. Java的锁机制

86. 死锁产生的原因

87. 三次握手和四次挥手,time_wait是什么状态

88. B树 B+树区别说一下

89. 数据库平时用到过什么 咱们先问MySQL MySQL索引原理知道吗，问了两种索引的区别

90. 索引的分类和优缺点

91. innodb和myisam的区别

92. 乐观锁悲观锁区别说一下

93. 数据库四种隔离状态 分别有什么问题

94. redis的数据结构

95. sortset底层，原理，怎么保证有序

96. 冯诺依曼计算机的结构

97. 操作系统的虚拟内存

98. 进程的调度

99. 进程间的通讯方式

100. 线程间的同步方式

101. 进程和线程的区别

102. 常见的排序算法

103. spring 事务实现

     ​    

## 扩展信息备查
1. http status备查

    1XX 信息
     100 Continue :表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

    2XX 成功

    200 OK
     204 No Content :请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端 往服务器发送信息，而不需要返回数据时使用。
     206 Partial Content :表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

    3XX 重定向

    301 Moved Permanently :永久性重定向
     302 Found :临时性重定向
     303 See Other :和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
     注:虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都 会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
     304 Not Modified :如果请求报文首部包含一些条件，例如:If-Match，If-Modified-Since，If-None- Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
     307 Temporary Redirect :临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

    4XX 客户端错误

    400 Bad Request :请求报文中存在语法错误。
     401 Unauthorized :该状态码表示发送的请求需要有认证信息(BASIC 认证、DIGEST 认证)。如果之前已进 行过一次请求，则表示用户认证失败。
     403 Forbidden :请求被拒绝。
     404 Not Found

    5XX 服务器错误
     500 Internal Server Error :服务器正在执行请求时发生错误。

    503 Service Unavailable :服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。