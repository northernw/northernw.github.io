# 全局异常处理与日志记录

[TOC]



为了给调⽤方比较友好的错误提示，我们会尽量捕获异常，转换为约定的通⽤格式，⽐如 DailiSoaResult、JsonCommonResponse等。

另一⽅面，为了方便问题排查，会尽量多地输出日志、记录出入参，这是不⼩的工作量，偶尔也会遗忘，或是增加修改成本（比如重命名等）。

这⾥介绍一些全局的处理方式，省去在每个方法里try catch和log，解放劳动⼒。 

全局的处理方式还有很多，可以灵活搭配使⽤。

更多原理理解，可以看⽂尾的链接。



# 全局异常处理

## web层

spring中的全局异常处理，主要有三种：

1. 注解`@ExceptionHandler`
2. 注解`@ControllerAdvice` -- **推荐使⽤**
3. 实现`HandlerExceptionResolver`接⼝



### 注解`@ExceptionHandler`

在controller的⽅法上使用。有多个controller的话，可以在BaseController中实现ExceptionHandler的处理，其他controller继承BaseController以共享这个异常处理。

优点：简单

缺点：继承的⽅式不太友好



目前代理工程中web⼤部分有BaseController，就直接使⽤这种⽅方式了。需要说明的是，项⽬中有比较复杂的配置，导致 @ExceptionHandler 方法的 @ResponseBody 注解失效，会序列化为xml结果，因此在方法内用Gson直接序列化输出。

代码示例：

```java
@RestController
public class UserController {
  
    @GetMapping("/user/get")
    public User get() {
        return User.builder().name("lily").age(11).build();
    }
  
    @GetMapping("/user/error")
    public User error() {
        throw new RuntimeException("system error");
    }
  
    @GetMapping("/user/illegal")
    public User illegal() {
        throw new IllegalArgumentException("no parameter");
    }
  
    @ExceptionHandler(Throwable.class)
    public Map<String, Object> exceptionHandler(Throwable t) {
        Map<String, Object> result = Maps.newHashMap();
        if (t instanceof IllegalArgumentException) {
						// 可以输出自定义的异常信息
            result.put("2", t.getMessage());
        } else {
						// 也可以输出统⼀的异常信息
						result.put("1", "系统异常"); 
        }
        return result;
    }
}
```



### 注解`@ControllerAdvice`

实际上是与` @ExceptionHandler` 搭配使用。

`@ControllerAdvice` 是一个特殊的 `@Component`，被注解的类中的`@ExceptionHandler`、` @InitBinder`、 `@ModelAttribute`⽅法将作⽤于所有的`@Controller`的类。

也就解决了需要继承BaseController的问题。

PS：`@RestControllerAdvice`同理，组合了 `@ResponseBody`。

代码示例：

```java
@ControllerAdvice
@Controller
public class UserControllerAdvice {
    @ExceptionHandler(Throwable.class)
    @ResponseBody
    public Map<String, Object> exceptionHandler(Throwable t) {
        Map<String, Object> result = Maps.newHashMap();
        if (t instanceof IllegalArgumentException) {
						// 可以输出⾃定义的异常信息
            result.put("2", t.getMessage());
        } else {
						// 也可以输出统⼀的异常信息
						result.put("1", "系统异常"); 
        }
        return result;
    }
}
```

或者：

```java
@RestControllerAdvice
public class UserControllerAdvice {
    @ExceptionHandler(Throwable.class)
    public Map<String, Object> exceptionHandler(Throwable t) {
			// ...
		} 
}
```



### 实现`HandlerExceptionResolver`接⼝

如果返回结果不是 `ModelAndView`，需要手动序列化结果。

代码示例：

```java
@Component
public class CustomExceptionResolver implements HandlerExceptionResolver {
		private Gson gson = new Gson();
		@Override
    public ModelAndView resolveException(HttpServletRequest request,
HttpServletResponse response, Object o, Exception e) {
        CommonResult commonResult = null;
        if (e instanceof IllegalArgumentException) {
            commonResult = CommonResult.fail(e.getMessage());
        } else {
            commonResult = CommonResult.fail("CustomExceptionResolver");
        }
        try {
            PrintWriter pw = response.getWriter();
            pw.println(gson.toJson(commonResult));
            pw.flush();
            pw.close();
        } catch (IOException e1) {
            e1.printStackTrace();
				}
        return new ModelAndView();
    }
}
```



### 简单原理理说明

1. 这三种方式，本质上都是`HandlerExceptionResolver`接口的一种实现，有不同的处理优先级。 

   在processDispatchResult中捕获mappedHandler（即controller对应请求方法）的异常后，转到processHandlerException中进行异常处理。

2. 异常处理理优先级

   `@ExceptionHandler`(图中1) > `@ControllerAdvice`(图中2) > `HandlerExceptionResolver`(图中3)

   当前者处理到，就break 1299行的for循环。

   ps：`HandlerExceptionResolver`的实现类可以通过 Ordered 接⼝（将order设为-1）使得执⾏顺序升到最前⾯。

![image-20200401154405730](/github/northernw.github.io/image/image-20200401154405730.png)





## soa层

⼀般Service的异常可以抛给web层统⼀处理。考虑到rpc调用，异常的序列化信息比较多（包括错误栈），可以将异常转化为错误码，对应不同的异常类型。

有两种方式的全局异常处理：

1. jsf/dubbo的filter
2. spring aop



### JSF的filter

代码示例

```java
@Slf4j
public class SoaExceptionFilter extends AbstractFilter {
    @Override
    public ResponseMessage invoke(RequestMessage request) {
        ResponseMessage response = null;
        String errorMsg = null;
        try {
            // sucRes返回
            response = getNext().invoke(request);
            if (!response.isError()) {
                return response;
            }
            throw response.getException();
        } catch (AgentServiceException | IllegalArgumentException e) {
            log.warn("custom error, msg = {}", e.getMessage());
            errorMsg = e.getMessage();
        } catch (Throwable e) {
            log.error("system error, request = {}", request.getInvocationBody(), e);

            errorMsg = AgentConstants.SYSTEM_ERROR;
        }
        // 构造faiRes返回
        response = MessageBuilder.buildResponse(request);
        response.setResponse(DailiSoaResult.failRes(errorMsg));
        return response;
    }
}
```



xml配置

```xml
<jsf:filter id="SoaExceptionFilter"
class="com.jd.ads.joint.agent.common.filter.SoaExceptionFilter"/>
```



### spring aop

代码示例

```java
@Aspect
@Slf4j
@Component
public class SoaExceptionAop {
    @Around("execution(* com.jd.ads.joint.agent.client..*.*(..))")
    public Object handleException(ProceedingJoinPoint pjp) {
        String errorMsg = null;
        try {
            return pjp.proceed();
        } catch (AgentServiceException | IllegalArgumentException e) {
            log.warn("custom error, msg = {}", e.getMessage());
            errorMsg = e.getMessage();
        } catch (Throwable e) {
            String args = Arrays.toString(pjp.getArgs());
            log.error("system error, request = {}", args, e);
            errorMsg = AgentConstants.SYSTEM_ERROR;
 
				}
        return DailiSoaResult.failRes(errorMsg);
    }
}
```



# 全局日志记录

web层可选方式：拦截器interceptor和spring aop.

soa层可选方式：filter和spring aop.

filter和aop的实现方式和全局异常处理类似。

主要规范：输出目标方法、调用⽅、出入参、异常。可以和全局异常处理配合使用（将日志记录的优先级设置为最低）。

## 示例

以web层为例。

### spring aop

代码示例

```java
@Component
@Aspect
@Slf4j
public class LogAspect {
    @Around("@annotation(requstMapping)")
    public Object log(ProceedingJoinPoint pjp) throws Throwable {
        ServletRequestAttributes sra = (ServletRequestAttributes)
RequestContextHolder.getRequestAttributes();
        if (sra == null) {
            return pjp.proceed();
        }
        long startTime = System.currentTimeMillis();
        Object object = pjp.proceed();
        long timeCost = System.currentTimeMillis() - startTime;
        HttpServletRequest request = sra.getRequest();
        String uri = request.getRequestURI();
        String ip = request.getRemoteHost();
        String args = Arrays.toString(pjp.getArgs());
        String pin = JdLoginUtils.getPin(request);
 
				// 入参和出参可选序列列化为json格式
				// 如果抽象为公共组件，还可加入app name和server ip
        log.info("ip = {}, uri = {}, pin = {}, args = {}, result = {}, time =
{}", ip, uri, pin, args, object, timeCost);
        return object;
    }
}
```





### 拦截器

实现`HandlerInterceptor`接⼝或继承`HandlerInterceptorAdapter`。

在 preHandle 记录入参、 postHandle（或 afterCompletion）记录出参（及异常）。
或者都在 afterCompletion中记录。

相对于切⾯，缺少处理耗时的记录。



# 参考链接

1. [深⼊理解 Spring 异常处理](https://www.infoq.cn/article/x-XFMSsN8IrDO2YR0T82)
2. [Spring进阶之@ControllerAdvice与统⼀异常处理](https://juejin.im/post/5cb95001e51d456e63760476)
3. [dubbo接口统一异常处理的两种方式](https://www.cnblogs.com/zcz527/p/7655235.html)
4. [SpringBoot 全局统一记录⽇志](https://www.cnblogs.com/hongdada/p/9100076.html)
5. [Spring MVC使用拦截器实现日志记录](https://blog.csdn.net/u011781521/article/details/78624276)



# 延伸阅读

1. [惊讶！我定的⽇志规范被CTO在全公司推广了](https://juejin.im/post/5e01a184e51d45581e44178a)
2. [Log4j2中的同步⽇志与异步日志](https://www.cnblogs.com/yeyang/p/7944906.html)

